'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var http = _interopDefault(require('http'));
var https = _interopDefault(require('https'));
var url = _interopDefault(require('url'));
var util = _interopDefault(require('util'));
var assert = _interopDefault(require('assert'));
var stream = _interopDefault(require('stream'));
var tty = _interopDefault(require('tty'));
var os = _interopDefault(require('os'));
var zlib = _interopDefault(require('zlib'));
var events = _interopDefault(require('events'));
var crypto = _interopDefault(require('crypto'));

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var roxBase = createCommonjsModule(function (module, exports) {
var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
  if ((_typeof2(exports)) === 'object' && (_typeof2(module)) === 'object') module.exports = factory();else if (typeof undefined === 'function' && undefined.amd) undefined([], factory);else if ((_typeof2(exports)) === 'object') exports["Rox"] = factory();else root["Rox"] = factory();
})(typeof self !== 'undefined' ? self : commonjsGlobal, function () {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 53);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var bind = __webpack_require__(26);

      /*global toString:true*/

      // utils is a library of generic helper functions non-specific to axios

      var toString = Object.prototype.toString;

      /**
       * Determine if a value is an Array
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an Array, otherwise false
       */
      function isArray(val) {
        return toString.call(val) === '[object Array]';
      }

      /**
       * Determine if a value is undefined
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if the value is undefined, otherwise false
       */
      function isUndefined(val) {
        return typeof val === 'undefined';
      }

      /**
       * Determine if a value is a Buffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Buffer, otherwise false
       */
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
      }

      /**
       * Determine if a value is an ArrayBuffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an ArrayBuffer, otherwise false
       */
      function isArrayBuffer(val) {
        return toString.call(val) === '[object ArrayBuffer]';
      }

      /**
       * Determine if a value is a FormData
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an FormData, otherwise false
       */
      function isFormData(val) {
        return typeof FormData !== 'undefined' && val instanceof FormData;
      }

      /**
       * Determine if a value is a view on an ArrayBuffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
       */
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }

      /**
       * Determine if a value is a String
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a String, otherwise false
       */
      function isString(val) {
        return typeof val === 'string';
      }

      /**
       * Determine if a value is a Number
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Number, otherwise false
       */
      function isNumber(val) {
        return typeof val === 'number';
      }

      /**
       * Determine if a value is an Object
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an Object, otherwise false
       */
      function isObject(val) {
        return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof2(val)) === 'object';
      }

      /**
       * Determine if a value is a Date
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Date, otherwise false
       */
      function isDate(val) {
        return toString.call(val) === '[object Date]';
      }

      /**
       * Determine if a value is a File
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a File, otherwise false
       */
      function isFile(val) {
        return toString.call(val) === '[object File]';
      }

      /**
       * Determine if a value is a Blob
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Blob, otherwise false
       */
      function isBlob(val) {
        return toString.call(val) === '[object Blob]';
      }

      /**
       * Determine if a value is a Function
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Function, otherwise false
       */
      function isFunction(val) {
        return toString.call(val) === '[object Function]';
      }

      /**
       * Determine if a value is a Stream
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Stream, otherwise false
       */
      function isStream(val) {
        return isObject(val) && isFunction(val.pipe);
      }

      /**
       * Determine if a value is a URLSearchParams object
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a URLSearchParams object, otherwise false
       */
      function isURLSearchParams(val) {
        return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
      }

      /**
       * Trim excess whitespace off the beginning and end of a string
       *
       * @param {String} str The String to trim
       * @returns {String} The String freed of excess whitespace
       */
      function trim(str) {
        return str.replace(/^\s*/, '').replace(/\s*$/, '');
      }

      /**
       * Determine if we're running in a standard browser environment
       *
       * This allows axios to run in a web worker, and react-native.
       * Both environments support XMLHttpRequest, but not fully standard globals.
       *
       * web workers:
       *  typeof window -> undefined
       *  typeof document -> undefined
       *
       * react-native:
       *  navigator.product -> 'ReactNative'
       * nativescript
       *  navigator.product -> 'NativeScript' or 'NS'
       */
      function isStandardBrowserEnv() {
        if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
          return false;
        }
        return typeof window !== 'undefined' && typeof document !== 'undefined';
      }

      /**
       * Iterate over an Array or an Object invoking a function for each item.
       *
       * If `obj` is an Array callback will be called passing
       * the value, index, and complete array for each item.
       *
       * If 'obj' is an Object callback will be called passing
       * the value, key, and complete object for each property.
       *
       * @param {Object|Array} obj The object to iterate
       * @param {Function} fn The callback to invoke for each item
       */
      function forEach(obj, fn) {
        // Don't bother if no value provided
        if (obj === null || typeof obj === 'undefined') {
          return;
        }

        // Force an array if not already something iterable
        if ((typeof obj === 'undefined' ? 'undefined' : _typeof2(obj)) !== 'object') {
          /*eslint no-param-reassign:0*/
          obj = [obj];
        }

        if (isArray(obj)) {
          // Iterate over array values
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          // Iterate over object keys
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }

      /**
       * Accepts varargs expecting each argument to be an object, then
       * immutably merges the properties of each object and returns result.
       *
       * When multiple objects contain the same key the later object in
       * the arguments list will take precedence.
       *
       * Example:
       *
       * ```js
       * var result = merge({foo: 123}, {foo: 456});
       * console.log(result.foo); // outputs 456
       * ```
       *
       * @param {Object} obj1 Object to merge
       * @returns {Object} Result of all merge properties
       */
      function merge() /* obj1, obj2, obj3, ... */{
        var result = {};
        function assignValue(val, key) {
          if (_typeof2(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof2(val)) === 'object') {
            result[key] = merge(result[key], val);
          } else {
            result[key] = val;
          }
        }

        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }

      /**
       * Function equal to merge with the difference being that no reference
       * to original objects is kept.
       *
       * @see merge
       * @param {Object} obj1 Object to merge
       * @returns {Object} Result of all merge properties
       */
      function deepMerge() /* obj1, obj2, obj3, ... */{
        var result = {};
        function assignValue(val, key) {
          if (_typeof2(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof2(val)) === 'object') {
            result[key] = deepMerge(result[key], val);
          } else if ((typeof val === 'undefined' ? 'undefined' : _typeof2(val)) === 'object') {
            result[key] = deepMerge({}, val);
          } else {
            result[key] = val;
          }
        }

        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }

      /**
       * Extends object a by mutably adding to it the properties of object b.
       *
       * @param {Object} a The object to be extended
       * @param {Object} b The object to copy properties from
       * @param {Object} thisArg The object to bind function to
       * @return {Object} The resulting value of object a
       */
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === 'function') {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }

      module.exports = {
        isArray: isArray,
        isArrayBuffer: isArrayBuffer,
        isBuffer: isBuffer,
        isFormData: isFormData,
        isArrayBufferView: isArrayBufferView,
        isString: isString,
        isNumber: isNumber,
        isObject: isObject,
        isUndefined: isUndefined,
        isDate: isDate,
        isFile: isFile,
        isBlob: isBlob,
        isFunction: isFunction,
        isStream: isStream,
        isURLSearchParams: isURLSearchParams,
        isStandardBrowserEnv: isStandardBrowserEnv,
        forEach: forEach,
        merge: merge,
        deepMerge: deepMerge,
        extend: extend,
        trim: trim
      };

      /***/
    },
    /* 1 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var levels = {
        debug: 0,
        info: 1,
        warn: 2,
        error: 3
      };

      var level = 'error';

      var Logger = function Logger() {
        var _this = this;

        _classCallCheck(this, Logger);

        this.debug = function (data) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          if (levels[level] <= levels.debug && console /* console not present on old IEs */) {
              var _console;

              (_console = console).log.apply(_console, [data].concat(args)); // eslint-disable-line no-console
            }
        };

        this.info = function (data) {
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          if (levels[level] <= levels.info && console /* console not present on old IEs */) {
              var _console2;

              (_console2 = console).info.apply(_console2, [data].concat(args)); // eslint-disable-line no-console
            }
        };

        this.warn = function (data) {
          for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          if (levels[level] <= levels.warn && console /* console not present on old IEs */) {
              var _console3;

              (_console3 = console).warn.apply(_console3, [data].concat(args)); // eslint-disable-line no-console
            }
        };

        this.error = function (data) {
          for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          if (console /* console not present on old IEs */) {
              var _console4;

              (_console4 = console).error.apply(_console4, [data].concat(args)); // eslint-disable-line no-console
            }
        };

        this.setVerboseMode = function (debugLevel) {
          if (debugLevel === 'verbose') {
            level = 'debug';
            _this.debug('Active verbose mode');
          } else {
            level = 'error';
          }
        };

        this.seLogger = function (newLogger) {
          logger = newLogger;
        };
      };

      var logger = new Logger();

      exports.default = logger;

      /***/
    },
    /* 2 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var API_HOST = 'x-api.rollout.io';
      var DEFAULT_CONFIGURATION = {
        API_HOST: API_HOST,
        CD_API_ENDPOINT: 'https://' + API_HOST + '/device/get_configuration',
        CD_S3_ENDPOINT: 'https://conf.rollout.io/',
        SS_API_ENDPOINT: 'https://' + API_HOST + '/device/update_state_store/',
        SS_S3_ENDPOINT: 'https://statestore.rollout.io/',
        CLIENT_DATA_CACHE_KEY: 'client_data',
        NOTIFICATIONS_ENDPOINT: 'https://push.rollout.io/sse',
        ANALYTICS_ENDPOINT: 'https://analytic.rollout.io'
      };

      var SELFMANAGEDMODE_CONFIGURATION = function SELFMANAGEDMODE_CONFIGURATION(_ref) {
        var analyticsURL = _ref.analyticsURL,
            serverURL = _ref.serverURL,
            pushUpdateURL = _ref.pushUpdateURL,
            configurationURL = _ref.configurationURL,
            stateURL = _ref.stateURL;
        return {
          CD_API_ENDPOINT: serverURL + '/device/get_configuration',
          SS_API_ENDPOINT: serverURL + '/device/update_state_store/',
          CLIENT_DATA_CACHE_KEY: 'client_data',
          ANALYTICS_ENDPOINT: analyticsURL,
          NOTIFICATIONS_ENDPOINT: pushUpdateURL + '/sse',
          CD_S3_ENDPOINT: configurationURL,
          SS_S3_ENDPOINT: stateURL
        };
      };

      var _activeConfiguration = Object.assign({}, DEFAULT_CONFIGURATION);

      exports.default = {
        get: function get(key) {
          return _activeConfiguration[key];
        },
        set: function set(key, value) {
          _activeConfiguration[key] = value;
        },
        setActive: function setActive(newConfiguration) {
          _activeConfiguration = Object.assign({}, newConfiguration);
        },
        setSelfManagedMode: function setSelfManagedMode(conf) {
          _activeConfiguration = Object.assign({}, DEFAULT_CONFIGURATION, SELFMANAGEDMODE_CONFIGURATION(conf));
        }
      };

      /***/
    },
    /* 3 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var ExperimentsRepository = function () {
        function ExperimentsRepository() {
          _classCallCheck(this, ExperimentsRepository);

          this.map = {};
        }

        _createClass(ExperimentsRepository, [{
          key: "setExperiments",
          value: function setExperiments(experiments) {
            this.map = {};

            experiments = experiments || [];
            experiments.forEach(function (element) {
              this.map[element.identifier] = element;
            }, this);
          }
        }, {
          key: "experimentWithName",
          value: function experimentWithName(name) {
            return this.map[name];
          }
        }, {
          key: "experimentForFlagName",
          value: function experimentForFlagName(flagName) {
            return this.experiments.find(function (e) {
              return e.flags && e.flags.some(function (f) {
                return f.name === flagName;
              });
            });
          }
        }, {
          key: "experimentForFlag",
          value: function experimentForFlag(flag) {
            return this.experimentForFlagName(flag.name);
          }
        }, {
          key: "experiments",
          get: function get() {
            var _this = this;

            return Object.keys(this.map).map(function (t) {
              return _this.map[t];
            });
          }
        }]);

        return ExperimentsRepository;
      }();

      var instance = new ExperimentsRepository();
      exports.default = instance;

      /***/
    },
    /* 4 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _RoxxParser = __webpack_require__(12);

      Object.defineProperty(exports, 'RoxxParser', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RoxxParser).default;
        }
      });

      var _ConfigurationParser = __webpack_require__(87);

      Object.defineProperty(exports, 'ConfigurationParser', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ConfigurationParser).default;
        }
      });

      var _RemoteConfigurationsParser = __webpack_require__(52);

      Object.defineProperty(exports, 'RemoteConfigurationsParser', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RemoteConfigurationsParser).default;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 5 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _FlagsSetter = __webpack_require__(54);

      Object.defineProperty(exports, 'FlagsSetter', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_FlagsSetter).default;
        }
      });

      var _ConfigurationSetter = __webpack_require__(55);

      Object.defineProperty(exports, 'ConfigurationSetter', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ConfigurationSetter).default;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 6 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _CustomPropertyRepository = __webpack_require__(7);

      Object.defineProperty(exports, 'CustomProperties', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CustomPropertyRepository).default;
        }
      });

      var _ExperimentsRepository = __webpack_require__(3);

      Object.defineProperty(exports, 'Experiments', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ExperimentsRepository).default;
        }
      });

      var _RoxConfigurationRepository = __webpack_require__(10);

      Object.defineProperty(exports, 'Configuration', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RoxConfigurationRepository).default;
        }
      });

      var _RoxFlagRepository = __webpack_require__(8);

      Object.defineProperty(exports, 'Flags', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RoxFlagRepository).default;
        }
      });

      var _TargetGroupRepository = __webpack_require__(11);

      Object.defineProperty(exports, 'TargetGroups', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TargetGroupRepository).default;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 7 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var CustomPropertyRepository = function () {
        function CustomPropertyRepository() {
          _classCallCheck(this, CustomPropertyRepository);

          this.store = new Map();
        }

        _createClass(CustomPropertyRepository, [{
          key: "has",
          value: function has(property) {
            return this.store.has(property.name);
          }
        }, {
          key: "get",
          value: function get(name) {
            return this.store.get(name);
          }
        }, {
          key: "set",
          value: function set(property) {
            this.store.set(property.name, property);
          }
        }, {
          key: "setIfNotExists",
          value: function setIfNotExists(property) {
            if (this.has(property)) {
              return;
            }
            this.set(property);
          }
        }, {
          key: "clear",
          value: function clear() {
            this.store.clear();
          }
        }, {
          key: "items",
          get: function get() {
            return Array.from(this.store.values());
          }
        }]);

        return CustomPropertyRepository;
      }();

      exports.default = new CustomPropertyRepository();

      /***/
    },
    /* 8 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RoxFlagRepository = undefined;

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _setters = __webpack_require__(5);

      var _ExperimentsRepository = __webpack_require__(3);

      var _ExperimentsRepository2 = _interopRequireDefault(_ExperimentsRepository);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var RoxFlagRepository = exports.RoxFlagRepository = function () {
        function RoxFlagRepository() {
          _classCallCheck(this, RoxFlagRepository);

          this.map = {};
        }

        _createClass(RoxFlagRepository, [{
          key: 'addFlag',
          value: function addFlag(name, flag) {
            flag.name = name;
            this.map[name] = flag;
            new _setters.FlagsSetter(this, _ExperimentsRepository2.default).setAddedFlag(flag);
          }
        }, {
          key: 'flagWithName',
          value: function flagWithName(name) {
            return this.map[name];
          }
        }, {
          key: 'flags',
          get: function get() {
            var _this = this;

            return Object.keys(this.map).map(function (t) {
              return _this.map[t];
            });
          }
        }, {
          key: 'items',
          get: function get() {
            return this.flags;
          }
        }]);

        return RoxFlagRepository;
      }();

      exports.default = new RoxFlagRepository();

      /***/
    },
    /* 9 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _ConfigurationFetcher = __webpack_require__(100);

      Object.defineProperty(exports, 'ConfigurationFetcher', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ConfigurationFetcher).default;
        }
      });

      var _RuntimeRegistry = __webpack_require__(47);

      Object.defineProperty(exports, 'RuntimeRegistry', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RuntimeRegistry).default;
        }
      });

      var _ClassRegister = __webpack_require__(104);

      Object.defineProperty(exports, 'ClassRegister', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ClassRegister).default;
        }
      });

      var _DeviceProperties = __webpack_require__(105);

      Object.defineProperty(exports, 'DeviceProperties', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DeviceProperties).default;
        }
      });

      var _RoxLogger = __webpack_require__(1);

      Object.defineProperty(exports, 'RoxLogger', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_RoxLogger).default;
        }
      });

      var _BugsnagReporter = __webpack_require__(13);

      Object.defineProperty(exports, 'BugsnagReporter', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_BugsnagReporter).default;
        }
      });

      var _Client = __webpack_require__(106);

      Object.defineProperty(exports, 'createRoxClient', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Client).default;
        }
      });

      var _DynamicApi = __webpack_require__(48);

      Object.defineProperty(exports, 'DynamicApi', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DynamicApi).default;
        }
      });

      var _repositories = __webpack_require__(6);

      Object.defineProperty(exports, 'Experiments', {
        enumerable: true,
        get: function get() {
          return _repositories.Experiments;
        }
      });
      Object.defineProperty(exports, 'Flags', {
        enumerable: true,
        get: function get() {
          return _repositories.Flags;
        }
      });

      var _parsers = __webpack_require__(4);

      Object.defineProperty(exports, 'ConfigurationParser', {
        enumerable: true,
        get: function get() {
          return _parsers.ConfigurationParser;
        }
      });

      var _setters = __webpack_require__(5);

      Object.defineProperty(exports, 'FlagsSetter', {
        enumerable: true,
        get: function get() {
          return _setters.FlagsSetter;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 10 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var RoxConfigurationRepository = function () {
        function RoxConfigurationRepository() {
          _classCallCheck(this, RoxConfigurationRepository);

          this.map = {};
        }

        _createClass(RoxConfigurationRepository, [{
          key: "addRemoteConfiguration",
          value: function addRemoteConfiguration(name, remoteConfiguration) {
            if (!remoteConfiguration._name) {
              remoteConfiguration._name = name;
            }

            this.map[name] = remoteConfiguration;
          }
        }, {
          key: "remoteConfigurationWithName",
          value: function remoteConfigurationWithName(name) {
            return this.map[name];
          }
        }, {
          key: "remoteConfigurations",
          get: function get() {
            var _this = this;

            return Object.keys(this.map).map(function (t) {
              return _this.map[t];
            });
          }
        }, {
          key: "items",
          get: function get() {
            return this.remoteConfigurations;
          }
        }]);

        return RoxConfigurationRepository;
      }();

      var instance = new RoxConfigurationRepository();
      exports.default = instance;

      /***/
    },
    /* 11 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var TargetGroupRepository = function () {
        function TargetGroupRepository() {
          _classCallCheck(this, TargetGroupRepository);

          this.map = {};
        }

        _createClass(TargetGroupRepository, [{
          key: "addTargetGroup",
          value: function addTargetGroup(targetGroup) {
            this.map[targetGroup.identifier] = targetGroup;
          }
        }, {
          key: "setTargetGroups",
          value: function setTargetGroups(targetGroups) {
            this.map = {};

            targetGroups = targetGroups || [];
            targetGroups.forEach(function (element) {
              this.map[element.identifier] = element;
            }, this);
          }
        }, {
          key: "targetGroupWithName",
          value: function targetGroupWithName(name) {
            return this.map[name];
          }
        }, {
          key: "targetGroups",
          get: function get() {
            var _this = this;

            return Object.keys(this.map).map(function (t) {
              return _this.map[t];
            });
          }
        }]);

        return TargetGroupRepository;
      }();

      var instance = new TargetGroupRepository();
      exports.default = instance;

      /***/
    },
    /* 12 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _RoxxTokenizer = __webpack_require__(56);

      var _BugsnagReporter = __webpack_require__(13);

      var _BugsnagReporter2 = _interopRequireDefault(_BugsnagReporter);

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      var _RoxxOperators = __webpack_require__(22);

      var RoxxOperatorsMap = _interopRequireWildcard(_RoxxOperators);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }return arr2;
        } else {
          return Array.from(arr);
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var RoxxParser = function () {
        /**
         * A parser for Roxx expressions.
         * Roxx expression are polish notation expressions {@link https://en.wikipedia.org/wiki/Polish_notation}
         * @class
         * @module RoxxParser
         * @param {*} cache - Optional token cache object. A default cache object is used if none specified.
         */
        function RoxxParser(cache) {
          _classCallCheck(this, RoxxParser);

          this._tokenizer = new _RoxxTokenizer.RoxxTokenizer();
          this._cache = cache || {};
        }

        /**
         * Given an operator function and stack, return an array of arguments for the operator.
         * @param {Function} operator
         * @param {Array} stack
         * @returns {Array} Array of arguments for operator
         * @private
         */

        _createClass(RoxxParser, [{
          key: '_argsArrayForOperator',
          value: function _argsArrayForOperator(operator, stack) {
            var argsArray = [];
            var length = operator.length;
            for (var i = 0; i < length; i++) {
              var arg = stack.pop();
              argsArray.push(arg);
            }

            return argsArray;
          }

          /**
           * Add context to specific operators after operator's args args.
           * @param {*} operator, args, context
           * @returns {Array} Args array with/without context
           */

        }, {
          key: '_modifyArgsHook',
          value: function _modifyArgsHook(_ref) {
            var operator = _ref.operator,
                args = _ref.args,
                context = _ref.context,
                callContext = _ref.callContext;

            var argsWithContext = args;
            if (context && RoxxOperatorsMap.operatorsWithContext.indexOf(operator) !== -1) {
              argsWithContext = [].concat(_toConsumableArray(args), [context]); // insert context
            }
            if (callContext) {
              return [].concat(_toConsumableArray(argsWithContext), [callContext]);
            }

            return argsWithContext;
          }

          /**
           * Tokenizes and caches expr if not available in cache.
           * @param {string} expr
           * @returns {Array} Tokenized version of expr
           */

        }, {
          key: 'compileExpression',
          value: function compileExpression(expr) {
            var tokens = this._cache[expr];
            if (!tokens) {
              tokens = this._tokenizer.tokenize(expr).reverse();
              this._cache[expr] = tokens;
            }
            return tokens;
          }

          /**
           * Evaluates a Roxx expression.
           *
           * @param {string} expr - Roxx expression string.
           * @returns {*} Result of Roxx expression evaluation.
           */

        }, {
          key: 'evaluateExpression',
          value: function evaluateExpression(expr) {
            var callContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var collector = arguments[3];

            var stack = [];
            var tokens = this.compileExpression(expr);

            var result = undefined;
            var length = tokens.length;
            try {
              for (var i = 0; i < length; i++) {
                var token = tokens[i];
                if (token.type == _RoxxTokenizer.RoxxTokenTypeRand) {
                  stack.push(token.value);
                } else if (token.type == _RoxxTokenizer.RoxxTokenTypeRator) {
                  var operator = RoxxOperatorsMap[token.value];
                  var args = this._argsArrayForOperator(operator, stack);
                  args = this._modifyArgsHook({ operator: operator, args: args, context: context, callContext: callContext });
                  var value = operator.apply(this, args);
                  stack.push(value);
                  var debugSentence = token.value + '(' + JSON.stringify(args) + ') => ' + value;
                  if (collector) {
                    collector.push(debugSentence);
                  }
                  _RoxLogger2.default.debug('Roxx: ' + debugSentence);
                } else {
                  stack.push(undefined);
                  break;
                }
              }
              result = stack.pop();
            } catch (err) {
              var message = 'Oh uh! An error occured during Roxx evaluation. ' + expr;
              _RoxLogger2.default.error(message, err);
              _BugsnagReporter2.default.error(message, err);
              result = false;
            } finally {
              return result;
            }
          }
        }]);

        return RoxxParser;
      }();

      exports.default = RoxxParser;

      /***/
    },
    /* 13 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _axios = __webpack_require__(14);

      var axios = _interopRequireWildcard(_axios);

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _objectWithoutProperties(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var BS_API_KEY = 'abbf3bd9c6e80eb1e8c0566c35b08748';
      var BS_NOTIFY_ENDPOINT = 'https://notify.bugsnag.com';

      var BugsnagReporter = function () {
        function BugsnagReporter() {
          _classCallCheck(this, BugsnagReporter);
        }

        _createClass(BugsnagReporter, [{
          key: 'init',
          value: function init(app_key, deviceProperties, networkOptions, selfManagedMode) {
            this.selfManagedMode = selfManagedMode;
            if (this.selfManagedMode) {
              return;
            }

            var _deviceProperties$get = deviceProperties.getProperties(),
                distinct_id = _deviceProperties$get.distinct_id,
                app_release = _deviceProperties$get.app_release,
                platform = _deviceProperties$get.platform,
                api_version = _deviceProperties$get.api_version,
                lib_version = _deviceProperties$get.lib_version,
                device = _objectWithoutProperties(_deviceProperties$get, ['distinct_id', 'app_release', 'platform', 'api_version', 'lib_version']);

            this.device = device;
            this.header = {
              apiKey: BS_API_KEY,
              notifier: {
                name: 'Rollout JavaScript SDK',
                version: lib_version,
                url: typeof window !== 'undefined' && window.location && window.location.href || undefined
              }
            };
            this.networkOptions = networkOptions;
            this.user = { distinct_id: distinct_id, app_release: app_release, app_key: app_key, platform: platform };
            this.app = { api_version: api_version, lib_version: lib_version };
          }
        }, {
          key: 'error',
          value: function error(message, exception) {
            if (this.selfManagedMode) {
              return;
            }
            return this._notify('error', message, exception);
          }
        }, {
          key: '_notify',
          value: function _notify(severity, message, exception) {
            var event = {
              payloadVersion: 4,
              exceptions: [],
              app: this.app,
              user: this.user,
              device: this.device,
              metaData: {
                data: {
                  message: message,
                  exception: exception.toString()
                }
              },
              severity: severity
            };

            if (exception instanceof Error) {
              event.exceptions.push({
                errorClass: exception.name,
                message: message + '\n' + exception.message + '\n' + exception.stack,
                stacktrace: []
              });
              event.groupingHash = exception.fileName;
            } else {
              event.exceptions.push({
                errorClass: 'Error',
                message: message,
                stacktrace: []
              });
            }

            return this._send([event]);
          }
        }, {
          key: '_send',
          value: function _send(events$$1) {
            var body = Object.assign({ events: events$$1 }, this.header);
            _RoxLogger2.default.debug('Sending bugsnag error report.');
            try {
              axios.post(BS_NOTIFY_ENDPOINT, body, this.networkOptions).catch(function (err) {
                _RoxLogger2.default.debug('Failed to send error report', err);
              });
              _RoxLogger2.default.debug('Successfully sent error report.');
            } catch (e) {
              _RoxLogger2.default.debug('Failed to send error report.', e);
            }
          }
        }]);

        return BugsnagReporter;
      }();

      exports.default = new BugsnagReporter();

      /***/
    },
    /* 14 */
    /***/function (module, exports, __webpack_require__) {

      module.exports = __webpack_require__(60);

      /***/
    },
    /* 15 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      function encode(val) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
      }

      /**
       * Build a URL by appending params to the end
       *
       * @param {string} url The base of the url (e.g., http://www.google.com)
       * @param {object} [params] The params to be appended
       * @returns {string} The formatted url
       */
      module.exports = function buildURL(url$$1, params, paramsSerializer) {
        /*eslint no-param-reassign:0*/
        if (!params) {
          return url$$1;
        }

        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];

          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === 'undefined') {
              return;
            }

            if (utils.isArray(val)) {
              key = key + '[]';
            } else {
              val = [val];
            }

            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + '=' + encode(v));
            });
          });

          serializedParams = parts.join('&');
        }

        if (serializedParams) {
          var hashmarkIndex = url$$1.indexOf('#');
          if (hashmarkIndex !== -1) {
            url$$1 = url$$1.slice(0, hashmarkIndex);
          }

          url$$1 += (url$$1.indexOf('?') === -1 ? '?' : '&') + serializedParams;
        }

        return url$$1;
      };

      /***/
    },
    /* 16 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var enhanceError = __webpack_require__(30);

      /**
       * Create an Error with the specified message, config, error code, request and response.
       *
       * @param {string} message The error message.
       * @param {Object} config The config.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       * @returns {Error} The created error.
       */
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };

      /***/
    },
    /* 17 */
    /***/function (module, exports) {

      module.exports = http;

      /***/
    },
    /* 18 */
    /***/function (module, exports) {

      module.exports = https;

      /***/
    },
    /* 19 */
    /***/function (module, exports) {

      module.exports = url;

      /***/
    },
    /* 20 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _CustomProperty = __webpack_require__(37);

      Object.defineProperty(exports, 'CustomProperty', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_CustomProperty).default;
        }
      });

      var _DeviceProperty = __webpack_require__(89);

      Object.defineProperty(exports, 'DeviceProperty', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DeviceProperty).default;
        }
      });

      var _DeploymentConfiguration = __webpack_require__(90);

      Object.defineProperty(exports, 'DeploymentConfiguration', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DeploymentConfiguration).default;
        }
      });

      var _Experiment = __webpack_require__(91);

      Object.defineProperty(exports, 'Experiment', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Experiment).default;
        }
      });

      var _Configuration = __webpack_require__(92);

      Object.defineProperty(exports, 'Configuration', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Configuration).default;
        }
      });

      var _TargetGroup = __webpack_require__(41);

      Object.defineProperty(exports, 'TargetGroup', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TargetGroup).default;
        }
      });

      var _Variant = __webpack_require__(99);

      Object.defineProperty(exports, 'Variant', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Variant).default;
        }
      });
      Object.defineProperty(exports, 'CallContextTypes', {
        enumerable: true,
        get: function get() {
          return _Variant.callContextTypes;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },
    /* 21 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isEnabled = isEnabled;
      exports.value = value;
      exports.getNumber = getNumber;
      exports.setDefaultsMode = setDefaultsMode;

      var _RoxxParser = __webpack_require__(12);

      var _RoxxParser2 = _interopRequireDefault(_RoxxParser);

      var _ExperimentsRepository = __webpack_require__(3);

      var _ExperimentsRepository2 = _interopRequireDefault(_ExperimentsRepository);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var isDefaultsMode = false;
      var DEFAULTS = {
        'rox.internal.pushUpdates': 'true',
        'rox.internal.considerThrottleInPush': 'false',
        'rox.internal.throttleFetchInSeconds': '0',
        'rox.internal.analytics': 'true'
      };

      function isEnabled(flagName) {
        var val = value(flagName);
        if (typeof val === 'boolean') return val;
        return val === 'true';
      }

      function value(flagName) {
        if (isDefaultsMode && DEFAULTS.hasOwnProperty(flagName)) {
          return DEFAULTS[flagName];
        }
        var internalExperiment = _ExperimentsRepository2.default.experimentForFlagName(flagName);
        if (!internalExperiment || !internalExperiment.deploymentConfiguration) return '';

        var value = new _RoxxParser2.default().evaluateExpression(internalExperiment.deploymentConfiguration.condition);
        return value;
      }

      function getNumber(flagName) {
        var val = value(flagName);
        return parseInt(val) || 0;
      }

      function setDefaultsMode(mode) {
        isDefaultsMode = mode;
      }

      /***/
    },
    /* 22 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.operatorsWithContext = exports.b64d = exports.concat = exports.md5 = exports.inArray = exports.property = exports.isTargetGroupPaired = exports.isInTargetGroup = exports.flagValue = exports.isInPercentageRange = exports.isInPercentage = exports.mergeSeed = exports.semverNe = exports.semverEq = exports.semverGte = exports.semverGt = exports.semverLte = exports.semverLt = exports.match = exports.gte = exports.gt = exports.lte = exports.lt = exports.ifThen = exports.not = exports.eq = exports.ne = exports.or = exports.and = exports.now = exports.isUndefined = undefined;

      var _TargetGroupRepository = __webpack_require__(11);

      var _TargetGroupRepository2 = _interopRequireDefault(_TargetGroupRepository);

      var _CustomPropertyRepository = __webpack_require__(7);

      var _CustomPropertyRepository2 = _interopRequireDefault(_CustomPropertyRepository);

      var _RoxFlagRepository = __webpack_require__(8);

      var _RoxFlagRepository2 = _interopRequireDefault(_RoxFlagRepository);

      var _ExperimentsRepository = __webpack_require__(3);

      var _ExperimentsRepository2 = _interopRequireDefault(_ExperimentsRepository);

      var _RoxxParser = __webpack_require__(12);

      var _RoxxParser2 = _interopRequireDefault(_RoxxParser);

      var _md = __webpack_require__(23);

      var _md2 = _interopRequireDefault(_md);

      var _DynamicProperties = __webpack_require__(25);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _versionCompare(v1, v2) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { zeroExtend: true, lexicographical: true };

        var lexicographical = options && options.lexicographical,
            zeroExtend = options && options.zeroExtend,
            v1parts = v1.split('.'),
            v2parts = v2.split('.');

        function isValidPart(x) {
          return (lexicographical ? /[0-9A-Za-z_-]+$/ : /^\d+$/).test(x);
        }

        if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
          return NaN;
        }

        if (zeroExtend) {
          while (v1parts.length < v2parts.length) {
            v1parts.push('0');
          }while (v2parts.length < v1parts.length) {
            v2parts.push('0');
          }
        }

        if (!lexicographical) {
          v1parts = v1parts.map(Number);
          v2parts = v2parts.map(Number);
        }

        for (var i = 0; i < v1parts.length; ++i) {
          if (v2parts.length == i) {
            return 1;
          }

          if (v1parts[i] == v2parts[i]) {
            continue;
          } else if (v1parts[i] > v2parts[i]) {
            return 1;
          } else {
            return -1;
          }
        }

        if (v1parts.length != v2parts.length) {
          return -1;
        }

        return 0;
      }

      var getBucket = function getBucket(seed) {
        var hash = (_md2.default)(seed, { asBytes: true });
        hash = (hash[0] & 0xff | (hash[1] & 0xff) << 8 | (hash[2] & 0xff) << 16 | (hash[3] & 0xff) << 24) >>> 0;

        var bucket = hash / (Math.pow(2, 32) - 1);
        return bucket;
      };

      var isUndefined = exports.isUndefined = function isUndefined(op) {
        return op === undefined;
      };
      var now = exports.now = function now() {
        return Date.now();
      };
      var and = exports.and = function and(op1, op2) {
        return op1 && op2;
      };
      var or = exports.or = function or(op1, op2) {
        return op1 || op2;
      };
      var ne = exports.ne = function ne(op1, op2) {
        return (isUndefined(op1) ? false : op1) !== (isUndefined(op2) ? false : op2);
      };
      var eq = exports.eq = function eq(op1, op2) {
        return (isUndefined(op1) ? false : op1) === (isUndefined(op2) ? false : op2);
      };
      var not = exports.not = function not(op) {
        return !op;
      };
      var ifThen = exports.ifThen = function ifThen(conditionExpression, trueExpression, falseExpression) {
        return conditionExpression ? trueExpression : falseExpression;
      };

      var lt = exports.lt = function lt(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'number' || typeof op2 !== 'number') return false;

        return op1 < op2;
      };

      var lte = exports.lte = function lte(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'number' || typeof op2 !== 'number') return false;

        return op1 <= op2;
      };

      var gt = exports.gt = function gt(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'number' || typeof op2 !== 'number') return false;

        return op1 > op2;
      };

      var gte = exports.gte = function gte(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'number' || typeof op2 !== 'number') return false;

        return op1 >= op2;
      };

      var match = exports.match = function match(op1, op2, op3) {
        var text = op1;
        var regex = new RegExp(op2, op3);

        var match = regex.exec(text);
        if (match) {
          return true;
        }

        return false;
      };

      var semverLt = exports.semverLt = function semverLt(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;

        return _versionCompare(op1, op2, { zeroExtend: true }) < 0;
      };

      var semverLte = exports.semverLte = function semverLte(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;

        return _versionCompare(op1, op2, { zeroExtend: true }) <= 0;
      };

      var semverGt = exports.semverGt = function semverGt(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;

        return _versionCompare(op1, op2, { zeroExtend: true }) > 0;
      };

      var semverGte = exports.semverGte = function semverGte(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;

        return _versionCompare(op1, op2, { zeroExtend: true }) >= 0;
      };

      var semverEq = exports.semverEq = function semverEq(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;

        return _versionCompare(op1, op2) == 0;
      };

      var semverNe = exports.semverNe = function semverNe(op1, op2) {
        if (isUndefined(op1) || isUndefined(op2)) return false;

        if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;

        return _versionCompare(op1, op2) != 0;
      };

      var mergeSeed = exports.mergeSeed = function mergeSeed(seed1, seed2) {
        return seed1 + '.' + seed2;
      };

      var isInPercentage = exports.isInPercentage = function isInPercentage(percentage, seed) {
        var bucket = getBucket(seed);
        var isInPercentage = bucket <= percentage;

        return isInPercentage;
      };

      var isInPercentageRange = exports.isInPercentageRange = function isInPercentageRange(percentageLow, percentageHigh, seed) {
        var bucket = getBucket(seed);
        var isInPercentage = bucket >= percentageLow && bucket <= percentageHigh;

        return isInPercentage;
      };

      var flagValue = exports.flagValue = function flagValue(flagName) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var internalContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var flag = _RoxFlagRepository2.default.flagWithName(flagName);

        if (flag) {
          return flag.getInternalValue(internalContext, context);
        }
        var exp = _ExperimentsRepository2.default.experimentForFlagName(flagName);
        if (exp && exp.deploymentConfiguration) {
          var expressionValue = new _RoxxParser2.default().evaluateExpression(exp.deploymentConfiguration.condition, internalContext, context);

          return expressionValue || 'false';
        }

        return 'false';
      };

      var isInTargetGroup = exports.isInTargetGroup = function isInTargetGroup(targetGroup) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var callContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var tg = _TargetGroupRepository2.default.targetGroupWithName(targetGroup);
        if (tg) {
          return new _RoxxParser2.default().evaluateExpression(tg.condition, callContext, context);
        } else {
          return false;
        }
      };

      var isTargetGroupPaired = exports.isTargetGroupPaired = function isTargetGroupPaired() {
        return false;
      };

      var property = exports.property = function property(propName) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var prop = _CustomPropertyRepository2.default.get(propName);
        if (!prop) {
          var handler = _DynamicProperties.DynamicPropertiesHandler && (_DynamicProperties.DynamicPropertiesHandler)();
          return handler ? handler(propName, context) : undefined;
        } else {
          return prop.getValue(context);
        }
      };

      var inArray = exports.inArray = function inArray(target, list) {
        return list.indexOf(target) !== -1;
      };

      var md5 = exports.md5 = function md5(str) {
        if (typeof str !== 'string') {
          return undefined;
        }
        return (_md2.default)(str);
      };

      var concat = exports.concat = function concat(str1, str2) {
        if (typeof str1 !== 'string' || typeof str2 !== 'string') {
          return undefined;
        }
        return '' + str1 + str2;
      };

      var b64d = exports.b64d = function b64d(value) {
        if (typeof value !== 'string') {
          return undefined;
        }
        return decodeURIComponent(Buffer.from(value, 'base64').toString('utf8'));
      };

      var operatorsWithContext = exports.operatorsWithContext = [isInTargetGroup, flagValue, property];

      /***/
    },
    /* 23 */
    /***/function (module, exports, __webpack_require__) {

      (function () {
        var crypt = __webpack_require__(58),
            utf8 = __webpack_require__(24).utf8,
            isBuffer = __webpack_require__(59),
            bin = __webpack_require__(24).bin,


        // The core
        md5 = function md5(message, options) {
          // Convert to byte array
          if (message.constructor == String) {
            if (options && options.encoding === 'binary') message = bin.stringToBytes(message);else message = utf8.stringToBytes(message);
          } else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);else if (!Array.isArray(message)) message = message.toString();
          // else, assume byte array already

          var m = crypt.bytesToWords(message),
              l = message.length * 8,
              a = 1732584193,
              b = -271733879,
              c = -1732584194,
              d = 271733878;

          // Swap endian
          for (var i = 0; i < m.length; i++) {
            m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
          }

          // Padding
          m[l >>> 5] |= 0x80 << l % 32;
          m[(l + 64 >>> 9 << 4) + 14] = l;

          // Method shortcuts
          var FF = md5._ff,
              GG = md5._gg,
              HH = md5._hh,
              II = md5._ii;

          for (var i = 0; i < m.length; i += 16) {

            var aa = a,
                bb = b,
                cc = c,
                dd = d;

            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
            c = FF(c, d, a, b, m[i + 10], 17, -42063);
            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);

            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);

            a = HH(a, b, c, d, m[i + 5], 4, -378558);
            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
            b = HH(b, c, d, a, m[i + 2], 23, -995338651);

            a = II(a, b, c, d, m[i + 0], 6, -198630844);
            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
            b = II(b, c, d, a, m[i + 5], 21, -57434055);
            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
            c = II(c, d, a, b, m[i + 10], 15, -1051523);
            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
            d = II(d, a, b, c, m[i + 15], 10, -30611744);
            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
            a = II(a, b, c, d, m[i + 4], 6, -145523070);
            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
            c = II(c, d, a, b, m[i + 2], 15, 718787259);
            b = II(b, c, d, a, m[i + 9], 21, -343485551);

            a = a + aa >>> 0;
            b = b + bb >>> 0;
            c = c + cc >>> 0;
            d = d + dd >>> 0;
          }

          return crypt.endian([a, b, c, d]);
        };

        // Auxiliary functions
        md5._ff = function (a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + (x >>> 0) + t;
          return (n << s | n >>> 32 - s) + b;
        };
        md5._gg = function (a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + (x >>> 0) + t;
          return (n << s | n >>> 32 - s) + b;
        };
        md5._hh = function (a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + (x >>> 0) + t;
          return (n << s | n >>> 32 - s) + b;
        };
        md5._ii = function (a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
          return (n << s | n >>> 32 - s) + b;
        };

        // Package private blocksize
        md5._blocksize = 16;
        md5._digestsize = 16;

        module.exports = function (message, options) {
          if (message === undefined || message === null) throw new Error('Illegal argument ' + message);

          var digestbytes = crypt.wordsToBytes(md5(message, options));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
        };
      })();

      /***/
    },
    /* 24 */
    /***/function (module, exports) {

      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function stringToBytes(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },

          // Convert a byte array to a string
          bytesToString: function bytesToString(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
          }
        },

        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function stringToBytes(str) {
            for (var bytes = [], i = 0; i < str.length; i++) {
              bytes.push(str.charCodeAt(i) & 0xFF);
            }return bytes;
          },

          // Convert a byte array to a string
          bytesToString: function bytesToString(bytes) {
            for (var str = [], i = 0; i < bytes.length; i++) {
              str.push(String.fromCharCode(bytes[i]));
            }return str.join('');
          }
        }
      };

      module.exports = charenc;

      /***/
    },
    /* 25 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultDynamicPropertyHandler = defaultDynamicPropertyHandler;
      exports.setDynamicPropertyHandler = setDynamicPropertyHandler;
      exports.DynamicPropertiesHandler = DynamicPropertiesHandler;
      var _defaultHandler = function _defaultHandler(propName, context) {
        return context ? context[propName] : undefined;
      };
      var _handler = _defaultHandler;

      function defaultDynamicPropertyHandler() {
        return _defaultHandler;
      }
      function setDynamicPropertyHandler(handler) {
        _handler = handler;
      }

      function DynamicPropertiesHandler() {
        return _handler;
      }

      /***/
    },
    /* 26 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };

      /***/
    },
    /* 27 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };

      /***/
    },
    /* 28 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);
      var normalizeHeaderName = __webpack_require__(65);

      var DEFAULT_CONTENT_TYPE = {
        'Content-Type': 'application/x-www-form-urlencoded'
      };

      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
          headers['Content-Type'] = value;
        }
      }

      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== 'undefined') {
          // For browsers use XHR adapter
          adapter = __webpack_require__(66);
        } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
          // For node use HTTP adapter
          adapter = __webpack_require__(72);
        }
        return adapter;
      }

      var defaults = {
        adapter: getDefaultAdapter(),

        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, 'Accept');
          normalizeHeaderName(headers, 'Content-Type');
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
            return data.toString();
          }
          if (utils.isObject(data)) {
            setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
            return JSON.stringify(data);
          }
          return data;
        }],

        transformResponse: [function transformResponse(data) {
          /*eslint no-param-reassign:0*/
          if (typeof data === 'string') {
            try {
              data = JSON.parse(data);
            } catch (e) {/* Ignore */}
          }
          return data;
        }],

        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,

        xsrfCookieName: 'XSRF-TOKEN',
        xsrfHeaderName: 'X-XSRF-TOKEN',

        maxContentLength: -1,

        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        }
      };

      defaults.headers = {
        common: {
          'Accept': 'application/json, text/plain, */*'
        }
      };

      utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });

      utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });

      module.exports = defaults;

      /***/
    },
    /* 29 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var createError = __webpack_require__(16);

      /**
       * Resolve or reject a Promise based on response status.
       *
       * @param {Function} resolve A function that resolves the promise.
       * @param {Function} reject A function that rejects the promise.
       * @param {object} response The response.
       */
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
        }
      };

      /***/
    },
    /* 30 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * Update an Error with the specified config, error code, and response.
       *
       * @param {Error} error The error to update.
       * @param {Object} config The config.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       * @returns {Error} The error.
       */

      module.exports = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }

        error.request = request;
        error.response = response;
        error.isAxiosError = true;

        error.toJSON = function () {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code
          };
        };
        return error;
      };

      /***/
    },
    /* 31 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var isAbsoluteURL = __webpack_require__(67);
      var combineURLs = __webpack_require__(68);

      /**
       * Creates a new URL by combining the baseURL with the requestedURL,
       * only when the requestedURL is not already an absolute URL.
       * If the requestURL is absolute, this function returns the requestedURL untouched.
       *
       * @param {string} baseURL The base URL
       * @param {string} requestedURL Absolute or relative URL to combine
       * @returns {string} The combined full path
       */
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };

      /***/
    },
    /* 32 */
    /***/function (module, exports, __webpack_require__) {

      var url$$1 = __webpack_require__(19);
      var http$$1 = __webpack_require__(17);
      var https$$1 = __webpack_require__(18);
      var assert$$1 = __webpack_require__(73);
      var Writable = __webpack_require__(74).Writable;
      var debug = __webpack_require__(75)("follow-redirects");

      // RFC7231§4.2.1: Of the request methods defined by this specification,
      // the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
      var SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };

      // Create handlers that pass events from native requests
      var eventHandlers = Object.create(null);
      ["abort", "aborted", "error", "socket", "timeout"].forEach(function (event) {
        eventHandlers[event] = function (arg) {
          this._redirectable.emit(event, arg);
        };
      });

      // An HTTP(S) request that can be redirected
      function RedirectableRequest(options, responseCallback) {
        // Initialize the request
        Writable.call(this);
        options.headers = options.headers || {};
        this._options = options;
        this._redirectCount = 0;
        this._redirects = [];
        this._requestBodyLength = 0;
        this._requestBodyBuffers = [];

        // Since http.request treats host as an alias of hostname,
        // but the url module interprets host as hostname plus port,
        // eliminate the host property to avoid confusion.
        if (options.host) {
          // Use hostname if set, because it has precedence
          if (!options.hostname) {
            options.hostname = options.host;
          }
          delete options.host;
        }

        // Attach a callback if passed
        if (responseCallback) {
          this.on("response", responseCallback);
        }

        // React to responses of native requests
        var self = this;
        this._onNativeResponse = function (response) {
          self._processResponse(response);
        };

        // Complete the URL object when necessary
        if (!options.pathname && options.path) {
          var searchPos = options.path.indexOf("?");
          if (searchPos < 0) {
            options.pathname = options.path;
          } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
          }
        }

        // Perform the first request
        this._performRequest();
      }
      RedirectableRequest.prototype = Object.create(Writable.prototype);

      // Writes buffered data to the current native request
      RedirectableRequest.prototype.write = function (data, encoding, callback) {
        // Validate input and shift parameters if necessary
        if (!(typeof data === "string" || (typeof data === 'undefined' ? 'undefined' : _typeof2(data)) === "object" && "length" in data)) {
          throw new Error("data should be a string, Buffer or Uint8Array");
        }
        if (typeof encoding === "function") {
          callback = encoding;
          encoding = null;
        }

        // Ignore empty buffers, since writing them doesn't invoke the callback
        // https://github.com/nodejs/node/issues/22066
        if (data.length === 0) {
          if (callback) {
            callback();
          }
          return;
        }
        // Only write when we don't exceed the maximum body length
        if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
          this._requestBodyLength += data.length;
          this._requestBodyBuffers.push({ data: data, encoding: encoding });
          this._currentRequest.write(data, encoding, callback);
        }
        // Error when we exceed the maximum body length
        else {
            this.emit("error", new Error("Request body larger than maxBodyLength limit"));
            this.abort();
          }
      };

      // Ends the current native request
      RedirectableRequest.prototype.end = function (data, encoding, callback) {
        // Shift parameters if necessary
        if (typeof data === "function") {
          callback = data;
          data = encoding = null;
        } else if (typeof encoding === "function") {
          callback = encoding;
          encoding = null;
        }

        // Write data and end
        var currentRequest = this._currentRequest;
        this.write(data || "", encoding, function () {
          currentRequest.end(null, null, callback);
        });
      };

      // Sets a header value on the current native request
      RedirectableRequest.prototype.setHeader = function (name, value) {
        this._options.headers[name] = value;
        this._currentRequest.setHeader(name, value);
      };

      // Clears a header value on the current native request
      RedirectableRequest.prototype.removeHeader = function (name) {
        delete this._options.headers[name];
        this._currentRequest.removeHeader(name);
      };

      // Proxy all other public ClientRequest methods
      ["abort", "flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive", "setTimeout"].forEach(function (method) {
        RedirectableRequest.prototype[method] = function (a, b) {
          return this._currentRequest[method](a, b);
        };
      });

      // Proxy all public ClientRequest properties
      ["aborted", "connection", "socket"].forEach(function (property) {
        Object.defineProperty(RedirectableRequest.prototype, property, {
          get: function get() {
            return this._currentRequest[property];
          }
        });
      });

      // Executes the next native request (initial or redirect)
      RedirectableRequest.prototype._performRequest = function () {
        // Load the native protocol
        var protocol = this._options.protocol;
        var nativeProtocol = this._options.nativeProtocols[protocol];
        if (!nativeProtocol) {
          this.emit("error", new Error("Unsupported protocol " + protocol));
          return;
        }

        // If specified, use the agent corresponding to the protocol
        // (HTTP and HTTPS use different types of agents)
        if (this._options.agents) {
          var scheme = protocol.substr(0, protocol.length - 1);
          this._options.agent = this._options.agents[scheme];
        }

        // Create the native request
        var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
        this._currentUrl = url$$1.format(this._options);

        // Set up event handlers
        request._redirectable = this;
        for (var event in eventHandlers) {
          /* istanbul ignore else */
          if (event) {
            request.on(event, eventHandlers[event]);
          }
        }

        // End a redirected request
        // (The first request must be ended explicitly with RedirectableRequest#end)
        if (this._isRedirect) {
          // Write the request entity and end.
          var i = 0;
          var buffers = this._requestBodyBuffers;
          (function writeNext() {
            if (i < buffers.length) {
              var buffer = buffers[i++];
              request.write(buffer.data, buffer.encoding, writeNext);
            } else {
              request.end();
            }
          })();
        }
      };

      // Processes a response from the current native request
      RedirectableRequest.prototype._processResponse = function (response) {
        // Store the redirected response
        if (this._options.trackRedirects) {
          this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: response.statusCode
          });
        }

        // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
        // that further action needs to be taken by the user agent in order to
        // fulfill the request. If a Location header field is provided,
        // the user agent MAY automatically redirect its request to the URI
        // referenced by the Location field value,
        // even if the specific status code is not understood.
        var location = response.headers.location;
        if (location && this._options.followRedirects !== false && response.statusCode >= 300 && response.statusCode < 400) {
          // RFC7231§6.4: A client SHOULD detect and intervene
          // in cyclical redirections (i.e., "infinite" redirection loops).
          if (++this._redirectCount > this._options.maxRedirects) {
            this.emit("error", new Error("Max redirects exceeded."));
            return;
          }

          // RFC7231§6.4: Automatic redirection needs to done with
          // care for methods not known to be safe […],
          // since the user might not wish to redirect an unsafe request.
          // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates
          // that the target resource resides temporarily under a different URI
          // and the user agent MUST NOT change the request method
          // if it performs an automatic redirection to that URI.
          var header;
          var headers = this._options.headers;
          if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {
            this._options.method = "GET";
            // Drop a possible entity and headers related to it
            this._requestBodyBuffers = [];
            for (header in headers) {
              if (/^content-/i.test(header)) {
                delete headers[header];
              }
            }
          }

          // Drop the Host header, as the redirect might lead to a different host
          if (!this._isRedirect) {
            for (header in headers) {
              if (/^host$/i.test(header)) {
                delete headers[header];
              }
            }
          }

          // Perform the redirected request
          var redirectUrl = url$$1.resolve(this._currentUrl, location);
          debug("redirecting to", redirectUrl);
          Object.assign(this._options, url$$1.parse(redirectUrl));
          this._isRedirect = true;
          this._performRequest();

          // Discard the remainder of the response to avoid waiting for data
          response.destroy();
        } else {
          // The response is not a redirect; return it as-is
          response.responseUrl = this._currentUrl;
          response.redirects = this._redirects;
          this.emit("response", response);

          // Clean up
          this._requestBodyBuffers = [];
        }
      };

      // Wraps the key/value object of protocols with redirect functionality
      function wrap(protocols) {
        // Default settings
        var exports = {
          maxRedirects: 21,
          maxBodyLength: 10 * 1024 * 1024
        };

        // Wrap each protocol
        var nativeProtocols = {};
        Object.keys(protocols).forEach(function (scheme) {
          var protocol = scheme + ":";
          var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
          var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

          // Executes a request, following redirects
          wrappedProtocol.request = function (options, callback) {
            if (typeof options === "string") {
              options = url$$1.parse(options);
              options.maxRedirects = exports.maxRedirects;
            } else {
              options = Object.assign({
                protocol: protocol,
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
              }, options);
            }
            options.nativeProtocols = nativeProtocols;
            assert$$1.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
          };

          // Executes a GET request, following redirects
          wrappedProtocol.get = function (options, callback) {
            var request = wrappedProtocol.request(options, callback);
            request.end();
            return request;
          };
        });
        return exports;
      }

      // Exports
      module.exports = wrap({ http: http$$1, https: https$$1 });
      module.exports.wrap = wrap;

      /***/
    },
    /* 33 */
    /***/function (module, exports, __webpack_require__) {

      /**
       * This is the common logic for both the Node.js and web browser
       * implementations of `debug()`.
       *
       * Expose `debug()` as the module.
       */

      exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
      exports.coerce = coerce;
      exports.disable = disable;
      exports.enable = enable;
      exports.enabled = enabled;
      exports.humanize = __webpack_require__(77);

      /**
       * Active `debug` instances.
       */
      exports.instances = [];

      /**
       * The currently active debug mode names, and names to skip.
       */

      exports.names = [];
      exports.skips = [];

      /**
       * Map of special "%n" handling functions, for the debug "format" argument.
       *
       * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
       */

      exports.formatters = {};

      /**
       * Select a color.
       * @param {String} namespace
       * @return {Number}
       * @api private
       */

      function selectColor(namespace) {
        var hash = 0,
            i;

        for (i in namespace) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return exports.colors[Math.abs(hash) % exports.colors.length];
      }

      /**
       * Create a debugger with the given `namespace`.
       *
       * @param {String} namespace
       * @return {Function}
       * @api public
       */

      function createDebug(namespace) {

        var prevTime;

        function debug() {
          // disabled?
          if (!debug.enabled) return;

          var self = debug;

          // set `diff` timestamp
          var curr = +new Date();
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;

          // turn the `arguments` into a proper Array
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }

          args[0] = exports.coerce(args[0]);

          if ('string' !== typeof args[0]) {
            // anything else let's inspect with %O
            args.unshift('%O');
          }

          // apply any `formatters` transformations
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            // if we encounter an escaped % then don't increase the array index
            if (match === '%%') return match;
            index++;
            var formatter = exports.formatters[format];
            if ('function' === typeof formatter) {
              var val = args[index];
              match = formatter.call(self, val);

              // now we need to remove `args[index]` since it's inlined in the `format`
              args.splice(index, 1);
              index--;
            }
            return match;
          });

          // apply env-specific formatting (colors, etc.)
          exports.formatArgs.call(self, args);

          var logFn = debug.log || exports.log || console.log.bind(console);
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = exports.enabled(namespace);
        debug.useColors = exports.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;

        // env-specific initialization logic for debug instances
        if ('function' === typeof exports.init) {
          exports.init(debug);
        }

        exports.instances.push(debug);

        return debug;
      }

      function destroy() {
        var index = exports.instances.indexOf(this);
        if (index !== -1) {
          exports.instances.splice(index, 1);
          return true;
        } else {
          return false;
        }
      }

      /**
       * Enables a debug mode by namespaces. This can include modes
       * separated by a colon and wildcards.
       *
       * @param {String} namespaces
       * @api public
       */

      function enable(namespaces) {
        exports.save(namespaces);

        exports.names = [];
        exports.skips = [];

        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) continue; // ignore empty strings
          namespaces = split[i].replace(/\*/g, '.*?');
          if (namespaces[0] === '-') {
            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            exports.names.push(new RegExp('^' + namespaces + '$'));
          }
        }

        for (i = 0; i < exports.instances.length; i++) {
          var instance = exports.instances[i];
          instance.enabled = exports.enabled(instance.namespace);
        }
      }

      /**
       * Disable debug output.
       *
       * @api public
       */

      function disable() {
        exports.enable('');
      }

      /**
       * Returns true if the given mode name is enabled, false otherwise.
       *
       * @param {String} name
       * @return {Boolean}
       * @api public
       */

      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
          if (exports.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
          if (exports.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Coerce `val`.
       *
       * @param {Mixed} val
       * @return {Mixed}
       * @api private
       */

      function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
      }

      /***/
    },
    /* 34 */
    /***/function (module, exports) {

      module.exports = util;

      /***/
    },
    /* 35 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      /**
       * Config-specific merge-function which creates a new config-object
       * by merging two configuration objects together.
       *
       * @param {Object} config1
       * @param {Object} config2
       * @returns {Object} New object resulting from merging config2 to config1
       */
      module.exports = function mergeConfig(config1, config2) {
        // eslint-disable-next-line no-param-reassign
        config2 = config2 || {};
        var config = {};

        var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
        var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
        var defaultToConfig2Keys = ['baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'];

        utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
          if (typeof config2[prop] !== 'undefined') {
            config[prop] = config2[prop];
          }
        });

        utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
          if (utils.isObject(config2[prop])) {
            config[prop] = utils.deepMerge(config1[prop], config2[prop]);
          } else if (typeof config2[prop] !== 'undefined') {
            config[prop] = config2[prop];
          } else if (utils.isObject(config1[prop])) {
            config[prop] = utils.deepMerge(config1[prop]);
          } else if (typeof config1[prop] !== 'undefined') {
            config[prop] = config1[prop];
          }
        });

        utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
          if (typeof config2[prop] !== 'undefined') {
            config[prop] = config2[prop];
          } else if (typeof config1[prop] !== 'undefined') {
            config[prop] = config1[prop];
          }
        });

        var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);

        var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

        utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
          if (typeof config2[prop] !== 'undefined') {
            config[prop] = config2[prop];
          } else if (typeof config1[prop] !== 'undefined') {
            config[prop] = config1[prop];
          }
        });

        return config;
      };

      /***/
    },
    /* 36 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * A `Cancel` is an object that is thrown when an operation is canceled.
       *
       * @class
       * @param {string=} message The message.
       */

      function Cancel(message) {
        this.message = message;
      }

      Cancel.prototype.toString = function toString() {
        return 'Cancel' + (this.message ? ': ' + this.message : '');
      };

      Cancel.prototype.__CANCEL__ = true;

      module.exports = Cancel;

      /***/
    },
    /* 37 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var _validateName = function _validateName(name) {
        if (typeof name === 'undefined' || name === '') {
          throw new Error('Custom property must be initialized with a name.');
        }
      };

      var _validateExplicitValue = function _validateExplicitValue(type, value) {
        if (value && value.constructor !== type && value.constructor !== Function) {
          throw new Error('Custom property initialized with an invalid type / value combination. (Type: ' + type + ', Value: ' + value + ')');
        }
      };

      var _validateDynamicValue = function _validateDynamicValue(value) {
        var argsExpected = value.length;
        if (argsExpected > 1) {
          throw new Error('Dynamic value of a custom property should be a function with maximum 1 argument');
        }
      };

      var CustomProperty = function () {
        function CustomProperty(name, type, value) {
          _classCallCheck(this, CustomProperty);

          _validateName(name);
          this._name = name;
          if (typeof value === 'function') {
            _validateDynamicValue(value);
            this._value = value;
          } else {
            _validateExplicitValue(type, value);
            this._value = function () {
              return value;
            };
          }
          this._type = type;
        }

        _createClass(CustomProperty, [{
          key: 'getValue',
          value: function getValue() {
            var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            return this._value(context);
          }
        }, {
          key: 'type',
          get: function get() {
            return this._type.name;
          }
        }, {
          key: 'externalType',
          get: function get() {
            return this._type.name;
          }
        }, {
          key: 'name',
          get: function get() {
            return this._name;
          }
        }, {
          key: 'value',
          get: function get() {
            return this._value();
          }
        }]);

        return CustomProperty;
      }();

      exports.default = CustomProperty;

      /***/
    },
    /* 38 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Manager = exports.Actions = undefined;

      var _Actions = __webpack_require__(93);

      var Actions = _interopRequireWildcard(_Actions);

      var _Manager = __webpack_require__(39);

      var Manager = _interopRequireWildcard(_Manager);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      exports.Actions = Actions;
      exports.Manager = Manager;

      /***/
    },
    /* 39 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var cloneDeep = __webpack_require__(40);
      var _context = {};

      function getContext() {
        return cloneDeep(_context);
      }

      function setContext(context) {
        _context = context;
      }

      exports.getContext = getContext;
      exports.setContext = setContext;

      /***/
    },
    /* 40 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * Module dependenices
       */

      var clone = __webpack_require__(94);
      var typeOf = __webpack_require__(96);
      var isPlainObject = __webpack_require__(97);

      function cloneDeep(val, instanceClone) {
        switch (typeOf(val)) {
          case 'object':
            return cloneObjectDeep(val, instanceClone);
          case 'array':
            return cloneArrayDeep(val, instanceClone);
          default:
            {
              return clone(val);
            }
        }
      }

      function cloneObjectDeep(val, instanceClone) {
        if (typeof instanceClone === 'function') {
          return instanceClone(val);
        }
        if (instanceClone || isPlainObject(val)) {
          var res = new val.constructor();
          for (var key in val) {
            res[key] = cloneDeep(val[key], instanceClone);
          }
          return res;
        }
        return val;
      }

      function cloneArrayDeep(val, instanceClone) {
        var res = new val.constructor(val.length);
        for (var i = 0; i < val.length; i++) {
          res[i] = cloneDeep(val[i], instanceClone);
        }
        return res;
      }

      /**
       * Expose `cloneDeep`
       */

      module.exports = cloneDeep;

      /***/
    },
    /* 41 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var TargetGroup = function TargetGroup(identifier, condition) {
        _classCallCheck(this, TargetGroup);

        this.identifier = identifier;
        this.condition = condition;
      };

      exports.default = TargetGroup;

      /***/
    },
    /* 42 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invokeImpression = invokeImpression;
      exports.setHandler = setHandler;
      exports.setAnalytics = setAnalytics;

      var _ = __webpack_require__(9);

      var _InternalFlags = __webpack_require__(21);

      var _ExperimentsRepository = __webpack_require__(3);

      var _ExperimentsRepository2 = _interopRequireDefault(_ExperimentsRepository);

      var _CustomPropertyRepository = __webpack_require__(7);

      var _CustomPropertyRepository2 = _interopRequireDefault(_CustomPropertyRepository);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var impressionHandler = null;
      var analytics = null;

      var createLightExperiment = function createLightExperiment(_ref) {
        var identifier = _ref.identifier,
            name = _ref.name,
            archived = _ref.archived,
            labels = _ref.labels;
        return {
          identifier: identifier,
          name: name,
          isArchived: archived,
          labels: labels
        };
      };

      function invokeImpression(value, flag, context) {
        var originExperiment = _ExperimentsRepository2.default.experimentForFlag(flag);
        try {
          if (analytics && originExperiment && (_InternalFlags.isEnabled)('rox.internal.analytics')) {
            var distinctIdProp = _CustomPropertyRepository2.default.get(originExperiment.stickinessProperty) || _CustomPropertyRepository2.default.get('rox.distinct_id');
            var distinctId = distinctIdProp ? distinctIdProp.getValue(context) : '';
            analytics.track({
              flag: flag.name,
              value: value,
              distinctId: distinctId,
              experimentId: originExperiment.identifier,
              experimentVersion: '0',
              type: 'IMPRESSION',
              time: new Date().getTime()
            });
          }
        } catch (err) {
          _.RoxLogger.error('Failed to send analytics', err);
        }
        if (typeof impressionHandler !== 'function') return;
        var experiment = originExperiment && createLightExperiment(originExperiment);
        impressionHandler({ name: flag.name, value: value }, experiment, context);
      }

      function setHandler(handler) {
        impressionHandler = handler;
      }

      function setAnalytics(a) {
        analytics = a;
      }

      /***/
    },
    /* 43 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildSetStateAPIURL = exports.buildSetStateS3URL = exports.buildAPIURL = undefined;

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _objectWithoutProperties(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      var buildAPIURL = function buildAPIURL(properties) {
        var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var app_key = properties.app_key,
            buid = properties.buid,
            relative_url = properties.relative_url,
            queryProps = _objectWithoutProperties(properties, ['app_key', 'buid', 'relative_url']);

        queryProps.cache_miss_relative_url = relative_url;
        var url$$1 = _config2.default.get('CD_API_ENDPOINT') + '/' + app_key + '/' + buid;
        return {
          url: endpoint || url$$1,
          body: queryProps
        };
      };

      exports.buildAPIURL = buildAPIURL;
      var buildSetStateS3URL = exports.buildSetStateS3URL = function buildSetStateS3URL(properties) {
        return '' + _config2.default.get('SS_S3_ENDPOINT') + properties.app_key + '/' + properties.md5;
      };

      var buildSetStateAPIURL = exports.buildSetStateAPIURL = function buildSetStateAPIURL(properties) {
        var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        return {
          url: endpoint || '' + _config2.default.get('SS_API_ENDPOINT') + properties.app_key + '/' + properties.md5,
          body: {
            platform: properties.platform,
            feature_flags: properties.feature_flags,
            custom_properties: properties.custom_properties,
            remoteVariables: properties.remoteVariables,
            devModeSecret: properties.devModeSecret
          }
        };
      };

      /***/
    },
    /* 44 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      exports.fetchFromCDN = fetchFromCDN;
      exports.fetchFromAPI = fetchFromAPI;
      exports.fetchFromRoxyAPI = fetchFromRoxyAPI;
      exports.stateFromCDN = stateFromCDN;
      exports.setStateToAPI = setStateToAPI;

      var _axios = __webpack_require__(14);

      var axios = _interopRequireWildcard(_axios);

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function fetchFromCDN(cache_url, req_opts) {
        return axios.get(cache_url, req_opts).then(function (_ref) {
          var data = _ref.data,
              status = _ref.status;

          if (status === 200 && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            if (data.result === 404) {
              _RoxLogger2.default.debug('succeed fetch from CDN, but it was missing');
              return Promise.reject();
            }
            _RoxLogger2.default.debug('succeed fetch from CDN');
            return data;
          }
        }).catch(function (err) {
          if (err.response.status == 404 || err.response.status == 403) {
            return Promise.reject();
          }
          _RoxLogger2.default.debug('Unexpected error calling get configuration, status code returned different from 403 or 404. error: ' + err);
          return;
        });
      }

      function processApiResponse(res) {
        var data = res.data,
            status = res.status;

        if (status === 200 && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
          _RoxLogger2.default.debug('succeed fetch from API');
          return data;
        }
        return Promise.reject(new Error('Unexpected response from ROX API'));
      }

      function fetchFromAPI(url$$1, body, req_opts) {
        return axios.post(url$$1, body, req_opts).then(processApiResponse);
      }

      function fetchFromRoxyAPI(url$$1, req_opts) {
        return axios.get(url$$1, req_opts).then(processApiResponse);
      }

      function stateFromCDN(url$$1, req_opts) {
        return axios.get(url$$1, req_opts).then(function (_ref2) {
          var data = _ref2.data,
              status = _ref2.status;

          if (status === 200 && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            if (data.result === 404) {
              _RoxLogger2.default.debug('succeed setState from CDN, but it was missing');
              return Promise.reject();
            }

            if (data.result === 200) {
              _RoxLogger2.default.debug('succeed setState from CDN');
              return;
            }
          }
          _RoxLogger2.default.debug('succeed setState, but with unexpected response');
          return;
        }).catch(function (err) {
          if (err.response.status == 404 || err.response.status == 403) {
            return Promise.reject();
          }
          _RoxLogger2.default.debug('Unexpected error calling setState, status code returned different from 403 or 404. error: ' + err);
          return;
        });
      }

      function setStateToAPI(url$$1, data, req_opts) {
        return axios.post(url$$1, data, req_opts).then(function (_ref3) {
          var status = _ref3.status;

          if (status === 200) {
            _RoxLogger2.default.debug('succeed setState from API');
            return;
          }
          return Promise.reject(new Error('Unexpected response from ROX API'));
        });
      }

      /***/
    },
    /* 45 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.STATE_GENERATOR_LIST = exports.BUID_GENERATOR_LIST = undefined;
      exports.generateStateMd5 = generateStateMd5;
      exports.generateBuid = generateBuid;

      var _md = __webpack_require__(23);

      var _md2 = _interopRequireDefault(_md);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var BUID_GENERATOR_LIST = exports.BUID_GENERATOR_LIST = ['lib_version', 'api_version', 'platform', 'app_key', 'customSigningCertificate'];

      var STATE_GENERATOR_LIST = exports.STATE_GENERATOR_LIST = ['platform', 'app_key', 'feature_flags', 'custom_properties', 'remoteVariables', 'devModeSecret'];

      function generate() {
        var all_properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var generator_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var payload = generator_list.map(function (key) {
          var value = all_properties[key];
          if (!value) {
            return key;
          }
          if (value.constructor === Object || value.constructor === Array) {
            return JSON.stringify(value);
          }
          return value;
        });
        return (_md2.default)(payload.join('|'));
      }

      function generateStateMd5() {
        var all_properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var generator_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATE_GENERATOR_LIST;

        return generate(all_properties, generator_list);
      }

      function generateBuid() {
        var all_properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var generator_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BUID_GENERATOR_LIST;

        return generate(all_properties, generator_list);
      }

      /***/
    },
    /* 46 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var FetcherStatus = exports.FetcherStatus = {
        APPLIED_FROM_EMBEDDED: 'APPLIED_FROM_EMBEDDED',
        APPLIED_FROM_CACHE: 'APPLIED_FROM_CACHE',
        APPLIED_FROM_NETWORK: 'APPLIED_FROM_NETWORK',
        ERROR_FETCH_FAILED: 'ERROR_FETCH_FAILED'
      };

      var FetcherResults = exports.FetcherResults = function FetcherResults(fetcherStatus, creationDate, hasChanges, errorDetails, clientData) {
        _classCallCheck(this, FetcherResults);

        this.fetcherStatus = fetcherStatus;
        this.creationDate = creationDate;
        this.hasChanges = hasChanges;
        this.errorDetails = errorDetails;
        this.clientData = clientData;
      };

      /***/
    },
    /* 47 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _RoxConfigurationRepository = __webpack_require__(10);

      var _RoxConfigurationRepository2 = _interopRequireDefault(_RoxConfigurationRepository);

      var _RoxFlagRepository = __webpack_require__(8);

      var _RoxFlagRepository2 = _interopRequireDefault(_RoxFlagRepository);

      var _CustomPropertyRepository = __webpack_require__(7);

      var _CustomPropertyRepository2 = _interopRequireDefault(_CustomPropertyRepository);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var RoxRuntimeRegistry = function () {
        function RoxRuntimeRegistry() {
          _classCallCheck(this, RoxRuntimeRegistry);
        }

        _createClass(RoxRuntimeRegistry, [{
          key: 'customProperties',
          get: function get() {
            var cp = [];
            _CustomPropertyRepository2.default.items.forEach(function (customProperties) {
              cp.push({
                name: customProperties.name,
                type: customProperties.type,
                externalType: customProperties.externalType
              });
            });
            return cp;
          }
        }, {
          key: 'featureFlags',
          get: function get() {
            var featureFlags = [];
            _RoxFlagRepository2.default.items.forEach(function (flag) {
              featureFlags.push({
                name: flag.name,
                defaultValue: flag.defaultValue,
                options: flag._options
              });
            });
            return featureFlags;
          }
        }, {
          key: 'remoteConfiguration',
          get: function get() {
            var remoteConfigurations = [];
            _RoxConfigurationRepository2.default.items.forEach(function (remoteConfiguration) {
              remoteConfigurations.push({
                name: remoteConfiguration.name,
                defaultValue: remoteConfiguration.defaultValue,
                type: remoteConfiguration.type,
                externalType: remoteConfiguration.externalType
              });
            });
            return remoteConfigurations;
          }
        }]);

        return RoxRuntimeRegistry;
      }();

      exports.default = RoxRuntimeRegistry;

      /***/
    },
    /* 48 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DynamicApi = function () {
        // the flag repository is kind of a statis/singleton, but that's bad for testing
        // please follow the move-as-parameter design
        // AKA (https://en.wikipedia.org/wiki/Dependency_injection)
        function DynamicApi(entityProvider, flagRepository, client) {
          _classCallCheck(this, DynamicApi);

          this.entityProvider = entityProvider;
          this.flagRepository = flagRepository;
          this.client = client;
        }

        _createClass(DynamicApi, [{
          key: "isEnabled",
          value: function isEnabled(name, defaultValue, context) {
            var flag = this.flagRepository.flagWithName(name);
            if (flag == null) {
              flag = this.entityProvider.createFlag(defaultValue);
              this.flagRepository.addFlag(name, flag);
              this.client.sendStateDebounced();
            }

            if (flag._getInternalIsEnabled == undefined) {
              return defaultValue;
            }

            var callContext = {};
            var value = flag._getInternalIsEnabled(callContext, context);
            if (callContext.isExperimenting) {
              return value;
            }
            return defaultValue;
          }
        }, {
          key: "value",
          value: function value(name, defaultValue, options, context) {
            if (!Array.isArray(options)) {
              context = options;
              options = null;
            }

            var variant = this.flagRepository.flagWithName(name);
            if (variant == null) {
              variant = this.entityProvider.createVariant(defaultValue, options);
              this.flagRepository.addFlag(name, variant);
              this.client.sendStateDebounced();
            }

            var callContext = {};
            var value = variant.getInternalValue(callContext, context);
            if (callContext.isExperimenting) {
              return value;
            }

            return defaultValue;
          }
        }]);

        return DynamicApi;
      }();

      exports.default = DynamicApi;

      /***/
    },
    /* 49 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof2(value);
        return value != null && (type == 'object' || type == 'function');
      }

      module.exports = isObject;

      /***/
    },
    /* 50 */
    /***/function (module, exports, __webpack_require__) {

      var freeGlobal = __webpack_require__(117);

      /** Detect free variable `self`. */
      var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof2(self)) == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      module.exports = root;

      /***/
    },
    /* 51 */
    /***/function (module, exports, __webpack_require__) {

      var root = __webpack_require__(50);

      /** Built-in value references. */
      var _Symbol = root.Symbol;

      module.exports = _Symbol;

      /***/
    },
    /* 52 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var terms = {
        REMOTE_CONFIG_NAME: 'name',
        REMOTE_CONFIG_TYPE: 'type',
        REMOTE_CONFIG_CONDITIONS: 'conditions'
      };

      var validateConfig = function validateConfig(i) {
        return i[terms.REMOTE_CONFIG_NAME] && i[terms.REMOTE_CONFIG_TYPE] && typeof i[terms.REMOTE_CONFIG_CONDITIONS] !== 'undefined';
      };

      exports.default = {
        parse: function parse() {
          var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          return json.filter(validateConfig);
        }
      };

      /***/
    },
    /* 53 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _setters = __webpack_require__(5);

      var Setters = _interopRequireWildcard(_setters);

      var _repositories = __webpack_require__(6);

      var Repositories = _interopRequireWildcard(_repositories);

      var _parsers = __webpack_require__(4);

      var Parsers = _interopRequireWildcard(_parsers);

      var _entities = __webpack_require__(20);

      var Entities = _interopRequireWildcard(_entities);

      var _lib = __webpack_require__(9);

      var lib = _interopRequireWildcard(_lib);

      var _context = __webpack_require__(38);

      var Context = _interopRequireWildcard(_context);

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      exports.default = Object.assign({}, lib, {
        Config: _config2.default,
        Entities: Entities,
        Parsers: Parsers,
        Setters: Setters,
        Repositories: Repositories,
        Context: Context
      });

      /***/
    },
    /* 54 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var FlagsSetter = function () {
        function FlagsSetter(flagRepo, experimentsRepo) {
          _classCallCheck(this, FlagsSetter);

          this.flagRepo = flagRepo;
          this.experimentsRepo = experimentsRepo;
        }

        _createClass(FlagsSetter, [{
          key: 'prepareFlagsWithExperiments',
          value: function prepareFlagsWithExperiments() {
            var _this = this;

            var experiments = this.experimentsRepo.experiments || [];
            _RoxLogger2.default.debug('Set experiments ' + JSON.stringify(experiments));

            var flagsWithCondition = [];
            experiments.forEach(function (experiment) {
              if (!experiment) {
                return;
              }

              experiment.flags.forEach(function (flag) {
                if (!flag) {
                  return;
                }

                var flagObject = _this.flagRepo.flagWithName(flag.name);
                if (flagObject) {
                  flagsWithCondition.push(flagObject);
                  _this.connectExperimentToFlag(flagObject, experiment.deploymentConfiguration.condition);
                }
              });
            });

            this.flagRepo.flags.forEach(function (flagToSet) {
              if (!flagsWithCondition.some(function (f) {
                return f === flagToSet;
              })) {
                _this.connectExperimentToFlag(flagToSet, undefined);
              }
            });
          }
        }, {
          key: 'setAddedFlag',
          value: function setAddedFlag(addedFlag) {
            var experiment = this.experimentsRepo.experimentForFlag(addedFlag);
            if (experiment) {
              this.connectExperimentToFlag(addedFlag, experiment.deploymentConfiguration.condition);
            }
          }
        }, {
          key: 'connectExperimentToFlag',
          value: function connectExperimentToFlag(flag, condition) {
            flag.condition = condition;
          }
        }]);

        return FlagsSetter;
      }();

      exports.default = FlagsSetter;

      /***/
    },
    /* 55 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _RoxConfigurationRepository = __webpack_require__(10);

      var _RoxConfigurationRepository2 = _interopRequireDefault(_RoxConfigurationRepository);

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var ConfigurationSetter = function () {
        function ConfigurationSetter() {
          _classCallCheck(this, ConfigurationSetter);
        }

        _createClass(ConfigurationSetter, [{
          key: 'prepareConfigurations',
          value: function prepareConfigurations() {
            var configFromAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            _RoxLogger2.default.debug('Set remote configurations ' + JSON.stringify(configFromAPI));
            configFromAPI.forEach(function (_ref) {
              var name = _ref.name,
                  conditions = _ref.conditions;

              var configuration = _RoxConfigurationRepository2.default.remoteConfigurationWithName(name);
              if (!configuration) {
                return;
              }

              configuration.condition = conditions;
            }, this);
          }
        }]);

        return ConfigurationSetter;
      }();

      exports.default = ConfigurationSetter;

      /***/
    },
    /* 56 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RoxxTokenizer = exports.RoxxTokenTypeRand = exports.RoxxTokenTypeRator = undefined;

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _StringTokenizer = __webpack_require__(57);

      var _StringTokenizer2 = _interopRequireDefault(_StringTokenizer);

      var _RoxxOperators = __webpack_require__(22);

      var RoxxOperatorsMap = _interopRequireWildcard(_RoxxOperators);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var operatorsList = Object.keys(RoxxOperatorsMap);

      var RoxxEscapedQuote = '\\"';
      var RoxxEscapedQuotePlaceholder = '\\RO_Q';

      var RoxxStringDelimiter = '"';
      var RoxxArrayStartDelimiter = '[';
      var RoxxArrayEndDelimiter = ']';
      var RoxxDictStartDelimiter = '{';
      var RoxxDictEndDelimiter = '}';
      var RoxxTokenDelimiters = '{}[]():, \t\r\n"';

      /**
       * Type identifier for ope*rator* tokens
       */
      var RoxxTokenTypeRator = exports.RoxxTokenTypeRator = 'operator';

      /**
       * Type identifier for ope*rand* tokens
       */
      var RoxxTokenTypeRand = exports.RoxxTokenTypeRand = 'operand';
      /**
       *
       */

      var RoxxTokenizer = exports.RoxxTokenizer = function () {
        function RoxxTokenizer() {
          _classCallCheck(this, RoxxTokenizer);

          this.tokenArray = [];
          this.arrayAccumulator = undefined;
          this.dictionaryAccumulator = undefined;
          this.dictKey = undefined;
        }

        /**
         * Converts a string token into a Roxx type object.
         * @param {string} token - The token to convert into a Roxx type.
         * @returns {object}
         */

        _createClass(RoxxTokenizer, [{
          key: '_stringToRoxx',
          value: function _stringToRoxx(token) {
            if (operatorsList.indexOf(token) !== -1) return { type: RoxxTokenTypeRator, value: token };
            if (token == 'true') return { type: RoxxTokenTypeRand, value: true };
            if (token == 'false') return { type: RoxxTokenTypeRand, value: false };
            if (token == 'undefined') return { type: RoxxTokenTypeRand, value: undefined };
            if (token.charAt(0) == '"' && token.charAt(token.length - 1) == '"') return { type: RoxxTokenTypeRand, value: token.substr(1, token.length - 2) };
            if (!isNaN(token)) return { type: RoxxTokenTypeRand, value: +token };

            return { type: 'UNKNOWN' };
          }

          /**
           * Pushes a token into either the arrayAccumulator or the tokenArray
           * according to context.
           * @param {*} token - the token to push
           */

        }, {
          key: 'push',
          value: function push(token) {
            if (this.dictionaryAccumulator && !this.dictKey) {
              this.dictKey = token.value;
            } else if (this.dictionaryAccumulator && this.dictKey) {
              this.dictionaryAccumulator[this.dictKey] = token.value;
              this.dictKey = undefined;
            } else if (this.arrayAccumulator) {
              this.arrayAccumulator.push(token.value);
            } else {
              this.tokenArray.push(token);
            }
          }

          /**
           * Produces a token array from an expression string. This array is later consumed by RoxxParser
           * @see RoxxParser
           * @param {string} expr - Roxx expression to tokenize
           * @returns {Array}
           */

        }, {
          key: 'tokenize',
          value: function tokenize(expr) {
            this.tokenArray = [];
            this.arrayAccumulator = undefined;
            this.dictionaryAccumulator = undefined;

            var delimitersToUse = RoxxTokenDelimiters;

            var expression = expr.replace(RoxxEscapedQuote, RoxxEscapedQuotePlaceholder);
            var tokenizer = new _StringTokenizer2.default(expression, delimitersToUse, true);

            var token, prevToken;
            while (tokenizer.hasMoreTokens()) {
              prevToken = token;
              token = tokenizer.nextTokenWithDelimiters(delimitersToUse);

              switch (token) {
                case RoxxDictStartDelimiter:
                  this.dictionaryAccumulator = {};
                  break;
                case RoxxDictEndDelimiter:
                  this.tokenArray.push({ type: RoxxTokenTypeRand, value: this.dictionaryAccumulator });
                  this.dictionaryAccumulator = undefined;
                  break;
                case RoxxArrayStartDelimiter:
                  this.arrayAccumulator = [];
                  break;
                case RoxxArrayEndDelimiter:
                  this.tokenArray.push({ type: RoxxTokenTypeRand, value: this.arrayAccumulator });
                  this.arrayAccumulator = undefined;
                  break;
                case RoxxStringDelimiter:
                  if (prevToken == RoxxStringDelimiter) {
                    // if previous token was also a string delimiter it means we encounterd an emptry string.
                    this.push({ type: RoxxTokenTypeRand, value: '' });
                  }

                  // Swap delimiters to use if needed. we do this so we can have strings with chars that are normally used as delimiters.
                  delimitersToUse = delimitersToUse == RoxxStringDelimiter ? RoxxTokenDelimiters : RoxxStringDelimiter;
                  break;
                default:
                  if (delimitersToUse == RoxxStringDelimiter) {
                    // If get a token that's not RoxxStringDelimiter while using RoxxStringDelimiter as delimiters It's the string value!
                    this.push({ type: RoxxTokenTypeRand, value: token.replace(RoxxEscapedQuotePlaceholder, RoxxEscapedQuote) });
                  } else if (RoxxTokenDelimiters.indexOf(token) == -1) {
                    // Is this token a delimiter or something else? if it's something else convert it to a roxx type and push.
                    this.push(this._stringToRoxx(token));
                  }
                  break;
              }
            }

            return this.tokenArray;
          }
        }]);

        return RoxxTokenizer;
      }();

      /***/
    },
    /* 57 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var StringTokenizer = function () {
        function StringTokenizer(string, delimiters, returnDelim) {
          _classCallCheck(this, StringTokenizer);

          this._string = string;
          this._delimiters = delimiters;
          this._returnDelim = returnDelim;
          this._position = 0;
        }

        _createClass(StringTokenizer, [{
          key: "countTokens",
          value: function countTokens() {
            var count = 0;
            var inToken = false;
            for (var i = this._position, length = this._string.length; i < length; i++) {
              if (this._delimiters.indexOf(this._string.charAt(i)) != -1) {
                if (this._returnDelim) count++;
                if (inToken) {
                  count++;
                  inToken = false;
                }
              } else {
                inToken = true;
              }
            }
            if (inToken) count++;
            return count;
          }
        }, {
          key: "hasMoreElements",
          value: function hasMoreElements() {
            return this.hasMoreTokens();
          }
        }, {
          key: "hasMoreTokens",
          value: function hasMoreTokens() {
            if (!this._delimiters) {
              return false;
            }

            var length = this._string.length;
            if (this._position < length) {
              if (this._returnDelim) return true;

              for (var i = this._position; i < length; i++) {
                if (this._delimiters.indexOf(this._string.charAt(i)) == -1) {
                  return true;
                }
              }
            }
            return false;
          }
        }, {
          key: "nextElement",
          value: function nextElement() {
            return this.nextToken();
          }
        }, {
          key: "nextToken",
          value: function nextToken() {
            if (!this._delimiters) {
              return undefined;
            }

            var i = this._position;
            var length = this._string.length;

            if (i < length) {
              if (this._returnDelim) {
                if (this._delimiters.indexOf(this._string.charAt(this._position)) != -1) return this._string.charAt(this._position++);
                for (this._position++; this._position < length; this._position++) {
                  if (this._delimiters.indexOf(this._string.charAt(this._position)) != -1) return this._string.substr(i, this._position - i);
                }return this._string.substr(i);
              }

              while (i < length && this._delimiters.indexOf(this._string.charAt(this._position)) != -1) {
                i++;
              }this._position = i;
              if (i < length) {
                for (this._position++; this._position < length; this._position++) {
                  if (this._delimiters.indexOf(this._string.charAt(this._position)) != -1) return this._string.substr(i, this._position - i);
                }return this._string.substr(i);
              }
            }

            return undefined;
          }
        }, {
          key: "nextTokenWithDelimiters",
          value: function nextTokenWithDelimiters(delimiters) {
            this._delimiters = delimiters;
            return this.nextToken();
          }
        }]);

        return StringTokenizer;
      }();

      exports.default = StringTokenizer;

      /***/
    },
    /* 58 */
    /***/function (module, exports) {

      (function () {
        var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
            crypt = {
          // Bit-wise rotation left
          rotl: function rotl(n, b) {
            return n << b | n >>> 32 - b;
          },

          // Bit-wise rotation right
          rotr: function rotr(n, b) {
            return n << 32 - b | n >>> b;
          },

          // Swap big-endian to little-endian and vice versa
          endian: function endian(n) {
            // If number given, swap endian
            if (n.constructor == Number) {
              return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
            }

            // Else, assume array and swap all items
            for (var i = 0; i < n.length; i++) {
              n[i] = crypt.endian(n[i]);
            }return n;
          },

          // Generate an array of any length of random bytes
          randomBytes: function randomBytes(n) {
            for (var bytes = []; n > 0; n--) {
              bytes.push(Math.floor(Math.random() * 256));
            }return bytes;
          },

          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function bytesToWords(bytes) {
            for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) {
              words[b >>> 5] |= bytes[i] << 24 - b % 32;
            }return words;
          },

          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function wordsToBytes(words) {
            for (var bytes = [], b = 0; b < words.length * 32; b += 8) {
              bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
            }return bytes;
          },

          // Convert a byte array to a hex string
          bytesToHex: function bytesToHex(bytes) {
            for (var hex = [], i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join('');
          },

          // Convert a hex string to a byte array
          hexToBytes: function hexToBytes(hex) {
            for (var bytes = [], c = 0; c < hex.length; c += 2) {
              bytes.push(parseInt(hex.substr(c, 2), 16));
            }return bytes;
          },

          // Convert a byte array to a base-64 string
          bytesToBase64: function bytesToBase64(bytes) {
            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
              var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
              for (var j = 0; j < 4; j++) {
                if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));else base64.push('=');
              }
            }
            return base64.join('');
          },

          // Convert a base-64 string to a byte array
          base64ToBytes: function base64ToBytes(base64) {
            // Remove non-base-64 characters
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

            for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0) continue;
              bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
          }
        };

        module.exports = crypt;
      })();

      /***/
    },
    /* 59 */
    /***/function (module, exports) {

      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */

      // The _isBuffer check is for Safari 5-7 support, because it's missing
      // Object.prototype.constructor. Remove this eventually
      module.exports = function (obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };

      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
      }

      // For Node v0.10 support. Remove this eventually.
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
      }

      /***/
    },
    /* 60 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);
      var bind = __webpack_require__(26);
      var Axios = __webpack_require__(61);
      var mergeConfig = __webpack_require__(35);
      var defaults = __webpack_require__(28);

      /**
       * Create an instance of Axios
       *
       * @param {Object} defaultConfig The default config for the instance
       * @return {Axios} A new instance of Axios
       */
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);

        // Copy axios.prototype to instance
        utils.extend(instance, Axios.prototype, context);

        // Copy context to instance
        utils.extend(instance, context);

        return instance;
      }

      // Create the default instance to be exported
      var axios = createInstance(defaults);

      // Expose Axios class to allow class inheritance
      axios.Axios = Axios;

      // Factory for creating new instances
      axios.create = function create(instanceConfig) {
        return createInstance(mergeConfig(axios.defaults, instanceConfig));
      };

      // Expose Cancel & CancelToken
      axios.Cancel = __webpack_require__(36);
      axios.CancelToken = __webpack_require__(85);
      axios.isCancel = __webpack_require__(27);

      // Expose all/spread
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = __webpack_require__(86);

      module.exports = axios;

      // Allow use of default import syntax in TypeScript
      module.exports.default = axios;

      /***/
    },
    /* 61 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);
      var buildURL = __webpack_require__(15);
      var InterceptorManager = __webpack_require__(62);
      var dispatchRequest = __webpack_require__(63);
      var mergeConfig = __webpack_require__(35);

      /**
       * Create a new instance of Axios
       *
       * @param {Object} instanceConfig The default config for the instance
       */
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }

      /**
       * Dispatch a request
       *
       * @param {Object} config The config specific for this request (merged with this.defaults)
       */
      Axios.prototype.request = function request(config) {
        /*eslint no-param-reassign:0*/
        // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof config === 'string') {
          config = arguments[1] || {};
          config.url = arguments[0];
        } else {
          config = config || {};
        }

        config = mergeConfig(this.defaults, config);

        // Set config.method
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = 'get';
        }

        // Hook up interceptors middleware
        var chain = [dispatchRequest, undefined];
        var promise = Promise.resolve(config);

        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          chain.unshift(interceptor.fulfilled, interceptor.rejected);
        });

        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          chain.push(interceptor.fulfilled, interceptor.rejected);
        });

        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }

        return promise;
      };

      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
      };

      // Provide aliases for supported request methods
      utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
        /*eslint func-names:0*/
        Axios.prototype[method] = function (url$$1, config) {
          return this.request(utils.merge(config || {}, {
            method: method,
            url: url$$1
          }));
        };
      });

      utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
        /*eslint func-names:0*/
        Axios.prototype[method] = function (url$$1, data, config) {
          return this.request(utils.merge(config || {}, {
            method: method,
            url: url$$1,
            data: data
          }));
        };
      });

      module.exports = Axios;

      /***/
    },
    /* 62 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      function InterceptorManager() {
        this.handlers = [];
      }

      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      InterceptorManager.prototype.use = function use(fulfilled, rejected) {
        this.handlers.push({
          fulfilled: fulfilled,
          rejected: rejected
        });
        return this.handlers.length - 1;
      };

      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       */
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };

      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       */
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };

      module.exports = InterceptorManager;

      /***/
    },
    /* 63 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);
      var transformData = __webpack_require__(64);
      var isCancel = __webpack_require__(27);
      var defaults = __webpack_require__(28);

      /**
       * Throws a `Cancel` if cancellation has been requested.
       */
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
      }

      /**
       * Dispatch a request to the server using the configured adapter.
       *
       * @param {object} config The config that is to be used for the request
       * @returns {Promise} The Promise to be fulfilled
       */
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);

        // Ensure headers exist
        config.headers = config.headers || {};

        // Transform request data
        config.data = transformData(config.data, config.headers, config.transformRequest);

        // Flatten headers
        config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);

        utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
          delete config.headers[method];
        });

        var adapter = config.adapter || defaults.adapter;

        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);

          // Transform response data
          response.data = transformData(response.data, response.headers, config.transformResponse);

          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);

            // Transform response data
            if (reason && reason.response) {
              reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
            }
          }

          return Promise.reject(reason);
        });
      };

      /***/
    },
    /* 64 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      /**
       * Transform the data for a request or a response
       *
       * @param {Object|String} data The data to be transformed
       * @param {Array} headers The headers for the request or response
       * @param {Array|Function} fns A single function or Array of functions
       * @returns {*} The resulting transformed data
       */
      module.exports = function transformData(data, headers, fns) {
        /*eslint no-param-reassign:0*/
        utils.forEach(fns, function transform(fn) {
          data = fn(data, headers);
        });

        return data;
      };

      /***/
    },
    /* 65 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };

      /***/
    },
    /* 66 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);
      var settle = __webpack_require__(29);
      var buildURL = __webpack_require__(15);
      var buildFullPath = __webpack_require__(31);
      var parseHeaders = __webpack_require__(69);
      var isURLSameOrigin = __webpack_require__(70);
      var createError = __webpack_require__(16);

      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;

          if (utils.isFormData(requestData)) {
            delete requestHeaders['Content-Type']; // Let the browser set it
          }

          var request = new XMLHttpRequest();

          // HTTP basic authentication
          if (config.auth) {
            var username = config.auth.username || '';
            var password = config.auth.password || '';
            requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
          }

          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

          // Set the request timeout in MS
          request.timeout = config.timeout;

          // Listen for ready state
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }

            // Prepare the response
            var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config,
              request: request
            };

            settle(resolve, reject, response);

            // Clean up request
            request = null;
          };

          // Handle browser request cancellation (as opposed to a manual cancellation)
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }

            reject(createError('Request aborted', config, 'ECONNABORTED', request));

            // Clean up request
            request = null;
          };

          // Handle low level network errors
          request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError('Network Error', config, null, request));

            // Clean up request
            request = null;
          };

          // Handle timeout
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request));

            // Clean up request
            request = null;
          };

          // Add xsrf header
          // This is only done if running in a standard browser environment.
          // Specifically not if we're in a web worker, or react-native.
          if (utils.isStandardBrowserEnv()) {
            var cookies = __webpack_require__(71);

            // Add xsrf header
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }

          // Add headers to the request
          if ('setRequestHeader' in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
                // Remove Content-Type if data is undefined
                delete requestHeaders[key];
              } else {
                // Otherwise add header to the request
                request.setRequestHeader(key, val);
              }
            });
          }

          // Add withCredentials to request if needed
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }

          // Add responseType to request if needed
          if (config.responseType) {
            try {
              request.responseType = config.responseType;
            } catch (e) {
              // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
              // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
              if (config.responseType !== 'json') {
                throw e;
              }
            }
          }

          // Handle progress if needed
          if (typeof config.onDownloadProgress === 'function') {
            request.addEventListener('progress', config.onDownloadProgress);
          }

          // Not all browsers support upload events
          if (typeof config.onUploadProgress === 'function' && request.upload) {
            request.upload.addEventListener('progress', config.onUploadProgress);
          }

          if (config.cancelToken) {
            // Handle cancellation
            config.cancelToken.promise.then(function onCanceled(cancel) {
              if (!request) {
                return;
              }

              request.abort();
              reject(cancel);
              // Clean up request
              request = null;
            });
          }

          if (requestData === undefined) {
            requestData = null;
          }

          // Send the request
          request.send(requestData);
        });
      };

      /***/
    },
    /* 67 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * Determines whether the specified URL is absolute
       *
       * @param {string} url The URL to test
       * @returns {boolean} True if the specified URL is absolute, otherwise false
       */

      module.exports = function isAbsoluteURL(url$$1) {
        // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
        // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
        // by any combination of letters, digits, plus, period, or hyphen.
        return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url$$1)
        );
      };

      /***/
    },
    /* 68 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * Creates a new URL by combining the specified URLs
       *
       * @param {string} baseURL The base URL
       * @param {string} relativeURL The relative URL
       * @returns {string} The combined URL
       */

      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
      };

      /***/
    },
    /* 69 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      // Headers whose duplicates are ignored by node
      // c.f. https://nodejs.org/api/http.html#http_message_headers
      var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

      /**
       * Parse headers into an object
       *
       * ```
       * Date: Wed, 27 Aug 2014 08:58:49 GMT
       * Content-Type: application/json
       * Connection: keep-alive
       * Transfer-Encoding: chunked
       * ```
       *
       * @param {String} headers Headers needing to be parsed
       * @returns {Object} Headers parsed into an object
       */
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;

        if (!headers) {
          return parsed;
        }

        utils.forEach(headers.split('\n'), function parser(line) {
          i = line.indexOf(':');
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));

          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === 'set-cookie') {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
            }
          }
        });

        return parsed;
      };

      /***/
    },
    /* 70 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      module.exports = utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
        function resolveURL(url$$1) {
          var href = url$$1;

          if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() :

      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();

      /***/
    },
    /* 71 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);

      module.exports = utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return match ? decodeURIComponent(match[3]) : null;
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      }() :

      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() {
            return null;
          },
          remove: function remove() {}
        };
      }();

      /***/
    },
    /* 72 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var utils = __webpack_require__(0);
      var settle = __webpack_require__(29);
      var buildFullPath = __webpack_require__(31);
      var buildURL = __webpack_require__(15);
      var http$$1 = __webpack_require__(17);
      var https$$1 = __webpack_require__(18);
      var httpFollow = __webpack_require__(32).http;
      var httpsFollow = __webpack_require__(32).https;
      var url$$1 = __webpack_require__(19);
      var zlib$$1 = __webpack_require__(83);
      var pkg = __webpack_require__(84);
      var createError = __webpack_require__(16);
      var enhanceError = __webpack_require__(30);

      var isHttps = /https:?/;

      /*eslint consistent-return:0*/
      module.exports = function httpAdapter(config) {
        return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
          var resolve = function resolve(value) {
            resolvePromise(value);
          };
          var reject = function reject(value) {
            rejectPromise(value);
          };
          var data = config.data;
          var headers = config.headers;

          // Set User-Agent (required by some servers)
          // Only set header if it hasn't been set in config
          // See https://github.com/axios/axios/issues/69
          if (!headers['User-Agent'] && !headers['user-agent']) {
            headers['User-Agent'] = 'axios/' + pkg.version;
          }

          if (data && !utils.isStream(data)) {
            if (Buffer.isBuffer(data)) {
              // Nothing to do...
            } else if (utils.isArrayBuffer(data)) {
              data = Buffer.from(new Uint8Array(data));
            } else if (utils.isString(data)) {
              data = Buffer.from(data, 'utf-8');
            } else {
              return reject(createError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config));
            }

            // Add Content-Length header if data exists
            headers['Content-Length'] = data.length;
          }

          // HTTP basic authentication
          var auth = undefined;
          if (config.auth) {
            var username = config.auth.username || '';
            var password = config.auth.password || '';
            auth = username + ':' + password;
          }

          // Parse url
          var fullPath = buildFullPath(config.baseURL, config.url);
          var parsed = url$$1.parse(fullPath);
          var protocol = parsed.protocol || 'http:';

          if (!auth && parsed.auth) {
            var urlAuth = parsed.auth.split(':');
            var urlUsername = urlAuth[0] || '';
            var urlPassword = urlAuth[1] || '';
            auth = urlUsername + ':' + urlPassword;
          }

          if (auth) {
            delete headers.Authorization;
          }

          var isHttpsRequest = isHttps.test(protocol);
          var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

          var options = {
            path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
            method: config.method.toUpperCase(),
            headers: headers,
            agent: agent,
            agents: { http: config.httpAgent, https: config.httpsAgent },
            auth: auth
          };

          if (config.socketPath) {
            options.socketPath = config.socketPath;
          } else {
            options.hostname = parsed.hostname;
            options.port = parsed.port;
          }

          var proxy = config.proxy;
          if (!proxy && proxy !== false) {
            var proxyEnv = protocol.slice(0, -1) + '_proxy';
            var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
            if (proxyUrl) {
              var parsedProxyUrl = url$$1.parse(proxyUrl);
              var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
              var shouldProxy = true;

              if (noProxyEnv) {
                var noProxy = noProxyEnv.split(',').map(function trim(s) {
                  return s.trim();
                });

                shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                  if (!proxyElement) {
                    return false;
                  }
                  if (proxyElement === '*') {
                    return true;
                  }
                  if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                    return true;
                  }

                  return parsed.hostname === proxyElement;
                });
              }

              if (shouldProxy) {
                proxy = {
                  host: parsedProxyUrl.hostname,
                  port: parsedProxyUrl.port
                };

                if (parsedProxyUrl.auth) {
                  var proxyUrlAuth = parsedProxyUrl.auth.split(':');
                  proxy.auth = {
                    username: proxyUrlAuth[0],
                    password: proxyUrlAuth[1]
                  };
                }
              }
            }
          }

          if (proxy) {
            options.hostname = proxy.host;
            options.host = proxy.host;
            options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
            options.port = proxy.port;
            options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;

            // Basic proxy authorization
            if (proxy.auth) {
              var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
              options.headers['Proxy-Authorization'] = 'Basic ' + base64;
            }
          }

          var transport;
          var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
          if (config.transport) {
            transport = config.transport;
          } else if (config.maxRedirects === 0) {
            transport = isHttpsProxy ? https$$1 : http$$1;
          } else {
            if (config.maxRedirects) {
              options.maxRedirects = config.maxRedirects;
            }
            transport = isHttpsProxy ? httpsFollow : httpFollow;
          }

          if (config.maxContentLength && config.maxContentLength > -1) {
            options.maxBodyLength = config.maxContentLength;
          }

          // Create the request
          var req = transport.request(options, function handleResponse(res) {
            if (req.aborted) return;

            // uncompress the response body transparently if required
            var stream$$1 = res;
            switch (res.headers['content-encoding']) {
              /*eslint default-case:0*/
              case 'gzip':
              case 'compress':
              case 'deflate':
                // add the unzipper to the body stream processing pipeline
                stream$$1 = res.statusCode === 204 ? stream$$1 : stream$$1.pipe(zlib$$1.createUnzip());

                // remove the content-encoding in order to not confuse downstream operations
                delete res.headers['content-encoding'];
                break;
            }

            // return the last request in case of redirects
            var lastRequest = res.req || req;

            var response = {
              status: res.statusCode,
              statusText: res.statusMessage,
              headers: res.headers,
              config: config,
              request: lastRequest
            };

            if (config.responseType === 'stream') {
              response.data = stream$$1;
              settle(resolve, reject, response);
            } else {
              var responseBuffer = [];
              stream$$1.on('data', function handleStreamData(chunk) {
                responseBuffer.push(chunk);

                // make sure the content length is not over the maxContentLength if specified
                if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
                  stream$$1.destroy();
                  reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest));
                }
              });

              stream$$1.on('error', function handleStreamError(err) {
                if (req.aborted) return;
                reject(enhanceError(err, config, null, lastRequest));
              });

              stream$$1.on('end', function handleStreamEnd() {
                var responseData = Buffer.concat(responseBuffer);
                if (config.responseType !== 'arraybuffer') {
                  responseData = responseData.toString(config.responseEncoding);
                }

                response.data = responseData;
                settle(resolve, reject, response);
              });
            }
          });

          // Handle errors
          req.on('error', function handleRequestError(err) {
            if (req.aborted) return;
            reject(enhanceError(err, config, null, req));
          });

          // Handle request timeout
          if (config.timeout) {
            // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
            // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
            // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
            // And then these socket which be hang up will devoring CPU little by little.
            // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
            req.setTimeout(config.timeout, function handleRequestTimeout() {
              req.abort();
              reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));
            });
          }

          if (config.cancelToken) {
            // Handle cancellation
            config.cancelToken.promise.then(function onCanceled(cancel) {
              if (req.aborted) return;

              req.abort();
              reject(cancel);
            });
          }

          // Send the request
          if (utils.isStream(data)) {
            data.on('error', function handleStreamError(err) {
              reject(enhanceError(err, config, null, req));
            }).pipe(req);
          } else {
            req.end(data);
          }
        });
      };

      /***/
    },
    /* 73 */
    /***/function (module, exports) {

      module.exports = assert;

      /***/
    },
    /* 74 */
    /***/function (module, exports) {

      module.exports = stream;

      /***/
    },
    /* 75 */
    /***/function (module, exports, __webpack_require__) {

      /**
       * Detect Electron renderer process, which is node, but we should
       * treat as a browser.
       */

      if (typeof process === 'undefined' || process.type === 'renderer') {
        module.exports = __webpack_require__(76);
      } else {
        module.exports = __webpack_require__(78);
      }

      /***/
    },
    /* 76 */
    /***/function (module, exports, __webpack_require__) {

      /**
       * This is the web browser implementation of `debug()`.
       *
       * Expose `debug()` as the module.
       */

      exports = module.exports = __webpack_require__(33);
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

      /**
       * Colors.
       */

      exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

      /**
       * Currently only WebKit-based Web Inspectors, Firefox >= v31,
       * and the Firebug extension (any Firefox version) are known
       * to support "%c" CSS customizations.
       *
       * TODO: add a `localStorage` variable to explicitly enable/disable colors
       */

      function useColors() {
        // NB: In an Electron preload script, document will be defined but not fully
        // initialized. Since we know we're in Chrome, we'll just detect this case
        // explicitly
        if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
          return true;
        }

        // Internet Explorer and Edge do not support colors.
        if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }

        // is webkit? http://stackoverflow.com/a/16459606/376773
        // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
        return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
        // is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
        // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
        // double check webkit in userAgent just in case we are in a worker
        typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }

      /**
       * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
       */

      exports.formatters.j = function (v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return '[UnexpectedJSONParseError]: ' + err.message;
        }
      };

      /**
       * Colorize log arguments if enabled.
       *
       * @api public
       */

      function formatArgs(args) {
        var useColors = this.useColors;

        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

        if (!useColors) return;

        var c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit');

        // the final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function (match) {
          if ('%%' === match) return;
          index++;
          if ('%c' === match) {
            // we only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
          }
        });

        args.splice(lastC, 0, c);
      }

      /**
       * Invokes `console.log()` when available.
       * No-op when `console.log` is not a "function".
       *
       * @api public
       */

      function log() {
        // this hackery is required for IE8/9, where
        // the `console.log` function doesn't have 'apply'
        return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof2(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }

      /**
       * Save `namespaces`.
       *
       * @param {String} namespaces
       * @api private
       */

      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem('debug');
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }

      /**
       * Load `namespaces`.
       *
       * @return {String} returns the previously persisted debug modes
       * @api private
       */

      function load() {
        var r;
        try {
          r = exports.storage.debug;
        } catch (e) {}

        // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
        if (!r && typeof process !== 'undefined' && 'env' in process) {
          r = process.env.DEBUG;
        }

        return r;
      }

      /**
       * Enable namespaces listed in `localStorage.debug` initially.
       */

      exports.enable(load());

      /**
       * Localstorage attempts to return the localstorage.
       *
       * This is necessary because safari throws
       * when a user disables cookies/localstorage
       * and you attempt to access it.
       *
       * @return {LocalStorage}
       * @api private
       */

      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }

      /***/
    },
    /* 77 */
    /***/function (module, exports) {

      /**
       * Helpers.
       */

      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var y = d * 365.25;

      /**
       * Parse or format the given `val`.
       *
       * Options:
       *
       *  - `long` verbose formatting [false]
       *
       * @param {String|Number} val
       * @param {Object} [options]
       * @throws {Error} throw an error if val is not a non-empty string or a number
       * @return {String|Number}
       * @api public
       */

      module.exports = function (val, options) {
        options = options || {};
        var type = typeof val === 'undefined' ? 'undefined' : _typeof2(val);
        if (type === 'string' && val.length > 0) {
          return parse(val);
        } else if (type === 'number' && isNaN(val) === false) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
      };

      /**
       * Parse the given `str` and return milliseconds.
       *
       * @param {String} str
       * @return {Number}
       * @api private
       */

      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;
          default:
            return undefined;
        }
      }

      /**
       * Short format for `ms`.
       *
       * @param {Number} ms
       * @return {String}
       * @api private
       */

      function fmtShort(ms) {
        if (ms >= d) {
          return Math.round(ms / d) + 'd';
        }
        if (ms >= h) {
          return Math.round(ms / h) + 'h';
        }
        if (ms >= m) {
          return Math.round(ms / m) + 'm';
        }
        if (ms >= s) {
          return Math.round(ms / s) + 's';
        }
        return ms + 'ms';
      }

      /**
       * Long format for `ms`.
       *
       * @param {Number} ms
       * @return {String}
       * @api private
       */

      function fmtLong(ms) {
        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
      }

      /**
       * Pluralization helper.
       */

      function plural(ms, n, name) {
        if (ms < n) {
          return;
        }
        if (ms < n * 1.5) {
          return Math.floor(ms / n) + ' ' + name;
        }
        return Math.ceil(ms / n) + ' ' + name + 's';
      }

      /***/
    },
    /* 78 */
    /***/function (module, exports, __webpack_require__) {

      /**
       * Module dependencies.
       */

      var tty$$1 = __webpack_require__(79);
      var util$$1 = __webpack_require__(34);

      /**
       * This is the Node.js implementation of `debug()`.
       *
       * Expose `debug()` as the module.
       */

      exports = module.exports = __webpack_require__(33);
      exports.init = init;
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;

      /**
       * Colors.
       */

      exports.colors = [6, 2, 3, 4, 5, 1];

      try {
        var supportsColor = __webpack_require__(80);
        if (supportsColor && supportsColor.level >= 2) {
          exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
        }
      } catch (err) {}
      // swallow - we only care if `supports-color` is available; it doesn't have to be.


      /**
       * Build up the default `inspectOpts` object from the environment variables.
       *
       *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
       */

      exports.inspectOpts = Object.keys(process.env).filter(function (key) {
        return (/^debug_/i.test(key)
        );
      }).reduce(function (obj, key) {
        // camel-case
        var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
          return k.toUpperCase();
        });

        // coerce string value into JS value
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

        obj[prop] = val;
        return obj;
      }, {});

      /**
       * Is stdout a TTY? Colored output is enabled when `true`.
       */

      function useColors() {
        return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$$1.isatty(process.stderr.fd);
      }

      /**
       * Map %o to `util.inspect()`, all on a single line.
       */

      exports.formatters.o = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util$$1.inspect(v, this.inspectOpts).split('\n').map(function (str) {
          return str.trim();
        }).join(' ');
      };

      /**
       * Map %o to `util.inspect()`, allowing multiple lines if needed.
       */

      exports.formatters.O = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util$$1.inspect(v, this.inspectOpts);
      };

      /**
       * Adds ANSI color escape codes if enabled.
       *
       * @api public
       */

      function formatArgs(args) {
        var name = this.namespace;
        var useColors = this.useColors;

        if (useColors) {
          var c = this.color;
          var colorCode = '\x1B[3' + (c < 8 ? c : '8;5;' + c);
          var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\x1B[0m';

          args[0] = prefix + args[0].split('\n').join('\n' + prefix);
          args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\x1B[0m');
        } else {
          args[0] = getDate() + name + ' ' + args[0];
        }
      }

      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return '';
        } else {
          return new Date().toISOString() + ' ';
        }
      }

      /**
       * Invokes `util.format()` with the specified arguments and writes to stderr.
       */

      function log() {
        return process.stderr.write(util$$1.format.apply(util$$1, arguments) + '\n');
      }

      /**
       * Save `namespaces`.
       *
       * @param {String} namespaces
       * @api private
       */

      function save(namespaces) {
        if (null == namespaces) {
          // If you set a process.env field to null or undefined, it gets cast to the
          // string 'null' or 'undefined'. Just delete instead.
          delete process.env.DEBUG;
        } else {
          process.env.DEBUG = namespaces;
        }
      }

      /**
       * Load `namespaces`.
       *
       * @return {String} returns the previously persisted debug modes
       * @api private
       */

      function load() {
        return process.env.DEBUG;
      }

      /**
       * Init logic for `debug` instances.
       *
       * Create a new `inspectOpts` object in case `useColors` is set
       * differently for a particular `debug` instance.
       */

      function init(debug) {
        debug.inspectOpts = {};

        var keys = Object.keys(exports.inspectOpts);
        for (var i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }

      /**
       * Enable namespaces listed in `process.env.DEBUG` initially.
       */

      exports.enable(load());

      /***/
    },
    /* 79 */
    /***/function (module, exports) {

      module.exports = tty;

      /***/
    },
    /* 80 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var os$$1 = __webpack_require__(81);
      var hasFlag = __webpack_require__(82);

      var env = process.env;

      var support = function support(level) {
        if (level === 0) {
          return false;
        }

        return {
          level: level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      };

      var supportLevel = function () {
        if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
          return 0;
        }

        if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
          return 3;
        }

        if (hasFlag('color=256')) {
          return 2;
        }

        if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
          return 1;
        }

        if (process.stdout && !process.stdout.isTTY) {
          return 0;
        }

        if (process.platform === 'win32') {
          // Node.js 7.5.0 is the first version of Node.js to include a patch to
          // libuv that enables 256 color output on Windows. Anything earlier and it
          // won't work. However, here we target Node.js 8 at minimum as it is an LTS
          // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
          // release that supports 256 colors.
          var osRelease = os$$1.release().split('.');
          if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return 2;
          }

          return 1;
        }

        if ('CI' in env) {
          if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {
            return sign in env;
          }) || env.CI_NAME === 'codeship') {
            return 1;
          }

          return 0;
        }

        if ('TEAMCITY_VERSION' in env) {
          return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
          );
        }

        if ('TERM_PROGRAM' in env) {
          var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

          switch (env.TERM_PROGRAM) {
            case 'iTerm.app':
              return version >= 3 ? 3 : 2;
            case 'Hyper':
              return 3;
            case 'Apple_Terminal':
              return 2;
            // No default
          }
        }

        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }

        if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }

        if ('COLORTERM' in env) {
          return 1;
        }

        if (env.TERM === 'dumb') {
          return 0;
        }

        return 0;
      }();

      if ('FORCE_COLOR' in env) {
        supportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : supportLevel || 1;
      }

      module.exports = process && support(supportLevel);

      /***/
    },
    /* 81 */
    /***/function (module, exports) {

      module.exports = os;

      /***/
    },
    /* 82 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      module.exports = function (flag, argv) {
        argv = argv || process.argv;

        var terminatorPos = argv.indexOf('--');
        var prefix = /^-{1,2}/.test(flag) ? '' : '--';
        var pos = argv.indexOf(prefix + flag);

        return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
      };

      /***/
    },
    /* 83 */
    /***/function (module, exports) {

      module.exports = zlib;

      /***/
    },
    /* 84 */
    /***/function (module, exports) {

      module.exports = { "name": "axios", "version": "0.19.2", "description": "Promise based HTTP client for the browser and node.js", "main": "index.js", "scripts": { "test": "grunt test && bundlesize", "start": "node ./sandbox/server.js", "build": "NODE_ENV=production grunt build", "preversion": "npm test", "version": "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json", "postversion": "git push && git push --tags", "examples": "node ./examples/server.js", "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js", "fix": "eslint --fix lib/**/*.js" }, "repository": { "type": "git", "url": "https://github.com/axios/axios.git" }, "keywords": ["xhr", "http", "ajax", "promise", "node"], "author": "Matt Zabriskie", "license": "MIT", "bugs": { "url": "https://github.com/axios/axios/issues" }, "homepage": "https://github.com/axios/axios", "devDependencies": { "bundlesize": "^0.17.0", "coveralls": "^3.0.0", "es6-promise": "^4.2.4", "grunt": "^1.0.2", "grunt-banner": "^0.6.0", "grunt-cli": "^1.2.0", "grunt-contrib-clean": "^1.1.0", "grunt-contrib-watch": "^1.0.0", "grunt-eslint": "^20.1.0", "grunt-karma": "^2.0.0", "grunt-mocha-test": "^0.13.3", "grunt-ts": "^6.0.0-beta.19", "grunt-webpack": "^1.0.18", "istanbul-instrumenter-loader": "^1.0.0", "jasmine-core": "^2.4.1", "karma": "^1.3.0", "karma-chrome-launcher": "^2.2.0", "karma-coverage": "^1.1.1", "karma-firefox-launcher": "^1.1.0", "karma-jasmine": "^1.1.1", "karma-jasmine-ajax": "^0.1.13", "karma-opera-launcher": "^1.0.0", "karma-safari-launcher": "^1.0.0", "karma-sauce-launcher": "^1.2.0", "karma-sinon": "^1.0.5", "karma-sourcemap-loader": "^0.3.7", "karma-webpack": "^1.7.0", "load-grunt-tasks": "^3.5.2", "minimist": "^1.2.0", "mocha": "^5.2.0", "sinon": "^4.5.0", "typescript": "^2.8.1", "url-search-params": "^0.10.0", "webpack": "^1.13.1", "webpack-dev-server": "^1.14.1" }, "browser": { "./lib/adapters/http.js": "./lib/adapters/xhr.js" }, "typings": "./index.d.ts", "dependencies": { "follow-redirects": "1.5.10" }, "bundlesize": [{ "path": "./dist/axios.min.js", "threshold": "5kB" }]

        /***/ };
    },
    /* 85 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var Cancel = __webpack_require__(36);

      /**
       * A `CancelToken` is an object that can be used to request cancellation of an operation.
       *
       * @class
       * @param {Function} executor The executor function.
       */
      function CancelToken(executor) {
        if (typeof executor !== 'function') {
          throw new TypeError('executor must be a function.');
        }

        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });

        var token = this;
        executor(function cancel(message) {
          if (token.reason) {
            // Cancellation has already been requested
            return;
          }

          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }

      /**
       * Throws a `Cancel` if cancellation has been requested.
       */
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };

      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token,
          cancel: cancel
        };
      };

      module.exports = CancelToken;

      /***/
    },
    /* 86 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * Syntactic sugar for invoking a function and expanding an array for arguments.
       *
       * Common use case would be to use `Function.prototype.apply`.
       *
       *  ```js
       *  function f(x, y, z) {}
       *  var args = [1, 2, 3];
       *  f.apply(null, args);
       *  ```
       *
       * With `spread` this example can be re-written.
       *
       *  ```js
       *  spread(function(x, y, z) {})([1, 2, 3]);
       *  ```
       *
       * @param {Function} callback
       * @returns {Function}
       */

      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };

      /***/
    },
    /* 87 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _ExperimentsParser = __webpack_require__(88);

      var _ExperimentsParser2 = _interopRequireDefault(_ExperimentsParser);

      var _TargetGroupsParser = __webpack_require__(126);

      var _TargetGroupsParser2 = _interopRequireDefault(_TargetGroupsParser);

      var _RemoteConfigurationsParser = __webpack_require__(52);

      var _RemoteConfigurationsParser2 = _interopRequireDefault(_RemoteConfigurationsParser);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var terms = {
        DATA_CONTAINER: 'data',
        APP_KEY: 'application',
        EXPERIMENTS: 'experiments',
        TARGET_GROUPS: 'targetGroups',
        REMOTE_CONFIGURATIONS: 'remoteVariables',
        SIGNED_DATE: 'signed_date'
      };

      var ConfigurationParser = function () {
        function ConfigurationParser(json, appKey) {
          var validateAppKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          _classCallCheck(this, ConfigurationParser);

          if (!json || (typeof json === 'undefined' ? 'undefined' : _typeof(json)) !== 'object') {
            throw new Error('ConfigurationParser should be constructed with JSON object. Received ' + json);
          }
          if (!appKey || typeof appKey !== 'string') {
            throw new Error('ConfigurationParser should be constructed with app key string. Received ' + appKey);
          }
          this._json = json;
          this._appKey = appKey;
          this._validateAppKey = validateAppKey;
        }

        _createClass(ConfigurationParser, [{
          key: 'parse',
          value: function parse() {
            var data = this._extractInnerJson(this._json);
            if (this._validateAppKey && data[terms.APP_KEY] !== this._appKey) {
              return null;
            }
            this._parseExperiments(data[terms.EXPERIMENTS]);
            this._parseTargetGroups(data[terms.TARGET_GROUPS]);
            this._parseRemoteConfigurations(data[terms.REMOTE_CONFIGURATIONS]);
            this._signedDate = new Date(this._json[terms.SIGNED_DATE]);

            return this;
          }
        }, {
          key: 'experiments',
          value: function experiments() {
            return this._experiments || [];
          }
        }, {
          key: 'targetGroups',
          value: function targetGroups() {
            return this._targetGroups || [];
          }
        }, {
          key: 'remoteConfigurations',
          value: function remoteConfigurations() {
            return this._configurations || [];
          }
        }, {
          key: 'signedDate',
          value: function signedDate() {
            return this._signedDate;
          }
        }, {
          key: '_extractInnerJson',
          value: function _extractInnerJson(json) {
            return JSON.parse(json[terms.DATA_CONTAINER]);
          }
        }, {
          key: '_parseExperiments',
          value: function _parseExperiments(experiments) {
            this._experiments = new _ExperimentsParser2.default(experiments).parse();
          }
        }, {
          key: '_parseTargetGroups',
          value: function _parseTargetGroups(targetGroups) {
            this._targetGroups = new _TargetGroupsParser2.default(targetGroups).parse();
          }
        }, {
          key: '_parseRemoteConfigurations',
          value: function _parseRemoteConfigurations(configurations) {
            this._configurations = _RemoteConfigurationsParser2.default.parse(configurations);
          }
        }]);

        return ConfigurationParser;
      }();

      exports.default = ConfigurationParser;

      /***/
    },
    /* 88 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _entities = __webpack_require__(20);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var terms = {
        DEPLOYMENT_CONFIGURATION: 'deploymentConfiguration',
        DEPLOYMENT_CONDITION: 'condition',
        EXPERIMENT_ARCHIVED: 'archived',
        EXPERIMENT_STICKY: 'sticky',
        EXPERIMENT_ID: '_id',
        EXPERIMENT_NAME: 'name',
        EXPERIMENT_FLAGS: 'featureFlags',
        EXPERIMENT_LABELS: 'labels',
        EXPERIMENT_STICKINESS_PROPERTY: 'stickinessProperty'
      };

      var ExperimentsParser = function () {
        function ExperimentsParser(json) {
          _classCallCheck(this, ExperimentsParser);

          this._json = json;
        }

        _createClass(ExperimentsParser, [{
          key: 'parse',
          value: function parse() {
            if (!this._json || !this._json.length) {
              return [];
            }

            var experiments = [];
            this._json.forEach(function (experimentJson) {
              if (!experimentJson || !experimentJson[terms.DEPLOYMENT_CONFIGURATION] || !experimentJson[terms.EXPERIMENT_ID] || !experimentJson[terms.EXPERIMENT_NAME] || !experimentJson[terms.EXPERIMENT_FLAGS]) {
                return;
              }

              var deploymentConfigurationJson = experimentJson[terms.DEPLOYMENT_CONFIGURATION];
              if (!deploymentConfigurationJson[terms.DEPLOYMENT_CONDITION]) {
                return;
              }

              var labels = experimentJson[terms.EXPERIMENT_LABELS] || [];

              var deploymentConfiguration = new _entities.DeploymentConfiguration(deploymentConfigurationJson[terms.DEPLOYMENT_CONDITION]);
              experiments.push(new _entities.Experiment(experimentJson[terms.EXPERIMENT_ID], experimentJson[terms.EXPERIMENT_NAME], !!experimentJson[terms.EXPERIMENT_ARCHIVED], !!experimentJson[terms.EXPERIMENT_STICKY], deploymentConfiguration, experimentJson[terms.EXPERIMENT_FLAGS], labels, experimentJson[terms.EXPERIMENT_STICKINESS_PROPERTY]));
            });

            return experiments;
          }
        }]);

        return ExperimentsParser;
      }();

      exports.default = ExperimentsParser;

      /***/
    },
    /* 89 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _get = function get(object, property, receiver) {
        if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);if (parent === null) {
            return undefined;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;if (getter === undefined) {
            return undefined;
          }return getter.call(receiver);
        }
      };

      var _CustomProperty2 = __webpack_require__(37);

      var _CustomProperty3 = _interopRequireDefault(_CustomProperty2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var DeviceProperty = function (_CustomProperty) {
        _inherits(DeviceProperty, _CustomProperty);

        function DeviceProperty() {
          _classCallCheck(this, DeviceProperty);

          return _possibleConstructorReturn(this, (DeviceProperty.__proto__ || Object.getPrototypeOf(DeviceProperty)).apply(this, arguments));
        }

        _createClass(DeviceProperty, [{
          key: 'name',
          get: function get() {
            return 'rox.' + _get(DeviceProperty.prototype.__proto__ || Object.getPrototypeOf(DeviceProperty.prototype), 'name', this);
          }
        }]);

        return DeviceProperty;
      }(_CustomProperty3.default);

      exports.default = DeviceProperty;

      /***/
    },
    /* 90 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DeploymentConfiguration = function DeploymentConfiguration(condition) {
        _classCallCheck(this, DeploymentConfiguration);

        this.condition = condition;
      };

      exports.default = DeploymentConfiguration;

      /***/
    },
    /* 91 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var Experiment = function Experiment(identifier, name, archived, sticky, deploymentConfiguration, flags, labels, stickinessProperty) {
        _classCallCheck(this, Experiment);

        this.identifier = identifier;
        this.name = name;
        this.archived = archived;
        this.sticky = sticky;
        this.deploymentConfiguration = deploymentConfiguration;
        this.flags = flags;
        this.labels = labels;
        this.stickinessProperty = stickinessProperty;
      };

      exports.default = Experiment;

      /***/
    },
    /* 92 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _parsers = __webpack_require__(4);

      var _context = __webpack_require__(38);

      var Context = _interopRequireWildcard(_context);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var parser = new _parsers.RoxxParser();
      var types = ['string', 'boolean', 'number'];

      var RoxConfiguration = function () {
        function RoxConfiguration(defaultValue) {
          _classCallCheck(this, RoxConfiguration);

          var valueType = typeof defaultValue === 'undefined' ? 'undefined' : _typeof(defaultValue);
          this._entityType = 'configuration';
          if (types.indexOf(valueType) === -1) {
            throw new Error('RoxConfiguration initialized with wrong type \'' + valueType + '\'');
          }

          Object.defineProperty(this, '_defaultValue', {
            value: defaultValue,
            writable: false,
            enumerable: false
          });

          Object.defineProperty(this, '_value', {
            value: defaultValue,
            writable: true,
            enumerable: false
          });

          Object.defineProperty(this, '_type', {
            value: valueType,
            writable: false,
            enumerable: false
          });

          Object.defineProperty(this, '_externalType', {
            value: valueType.charAt(0).toUpperCase() + valueType.slice(1),
            writable: false,
            enumerable: false
          });

          Object.defineProperty(this, '_name', {
            value: null,
            writable: true,
            enumerable: false
          });
        }

        _createClass(RoxConfiguration, [{
          key: 'getValue',
          value: function getValue() {
            var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (this.condition) {
              var mergedContext = Context.Actions.getMergedContextWithGlobal(context);

              var value = parser.evaluateExpression(this.condition, {}, mergedContext);

              if (this._type !== (typeof value === 'undefined' ? 'undefined' : _typeof(value)) || value === undefined) {
                this._value = this._defaultValue;
              } else {
                this._value = value;
              }
            }
            return this._value;
          }
        }, {
          key: 'name',
          get: function get() {
            return this._name;
          }
        }, {
          key: 'type',
          get: function get() {
            return this._type;
          }
        }, {
          key: 'externalType',
          get: function get() {
            return this._externalType;
          }
        }, {
          key: 'defaultValue',
          get: function get() {
            return this._defaultValue;
          }
        }]);

        return RoxConfiguration;
      }();

      exports.default = RoxConfiguration;

      /***/
    },
    /* 93 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getMergedContext = getMergedContext;
      exports.getMergedContextWithGlobal = getMergedContextWithGlobal;

      var _Manager = __webpack_require__(39);

      var Manager = _interopRequireWildcard(_Manager);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      var cloneDeep = __webpack_require__(40);

      function getMergedContext(context, contextToBeMerged) {
        if (!context) return cloneDeep(contextToBeMerged);
        var mergedContext = Object.assign({}, context, contextToBeMerged);
        return cloneDeep(mergedContext);
      }

      function getMergedContextWithGlobal(contextToBeMerged) {
        var globalContext = Manager.getContext();
        if (!contextToBeMerged) return globalContext;
        var mergedContext = Object.assign({}, globalContext, contextToBeMerged);
        return cloneDeep(mergedContext);
      }

      /***/
    },
    /* 94 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /*!
       * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
       *
       * Copyright (c) 2015-present, Jon Schlinkert.
       * Released under the MIT License.
       */

      var valueOf = Symbol.prototype.valueOf;
      var typeOf = __webpack_require__(95);

      function clone(val, deep) {
        switch (typeOf(val)) {
          case 'array':
            return val.slice();
          case 'object':
            return Object.assign({}, val);
          case 'date':
            return new val.constructor(Number(val));
          case 'map':
            return new Map(val);
          case 'set':
            return new Set(val);
          case 'buffer':
            return cloneBuffer(val);
          case 'symbol':
            return cloneSymbol(val);
          case 'arraybuffer':
            return cloneArrayBuffer(val);
          case 'float32array':
          case 'float64array':
          case 'int16array':
          case 'int32array':
          case 'int8array':
          case 'uint16array':
          case 'uint32array':
          case 'uint8clampedarray':
          case 'uint8array':
            return cloneTypedArray(val);
          case 'regexp':
            return cloneRegExp(val);
          case 'error':
            return Object.create(val);
          default:
            {
              return val;
            }
        }
      }

      function cloneRegExp(val) {
        var flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
        var re = new val.constructor(val.source, flags);
        re.lastIndex = val.lastIndex;
        return re;
      }

      function cloneArrayBuffer(val) {
        var res = new val.constructor(val.byteLength);
        new Uint8Array(res).set(new Uint8Array(val));
        return res;
      }

      function cloneTypedArray(val, deep) {
        return new val.constructor(val.buffer, val.byteOffset, val.length);
      }

      function cloneBuffer(val) {
        var len = val.length;
        var buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
        val.copy(buf);
        return buf;
      }

      function cloneSymbol(val) {
        return valueOf ? Object(valueOf.call(val)) : {};
      }

      /**
       * Expose `clone`
       */

      module.exports = clone;

      /***/
    },
    /* 95 */
    /***/function (module, exports) {

      var toString = Object.prototype.toString;

      module.exports = function kindOf(val) {
        if (val === void 0) return 'undefined';
        if (val === null) return 'null';

        var type = typeof val === 'undefined' ? 'undefined' : _typeof2(val);
        if (type === 'boolean') return 'boolean';
        if (type === 'string') return 'string';
        if (type === 'number') return 'number';
        if (type === 'symbol') return 'symbol';
        if (type === 'function') {
          return isGeneratorFn(val) ? 'generatorfunction' : 'function';
        }

        if (isArray(val)) return 'array';
        if (isBuffer(val)) return 'buffer';
        if (isArguments(val)) return 'arguments';
        if (isDate(val)) return 'date';
        if (isError(val)) return 'error';
        if (isRegexp(val)) return 'regexp';

        switch (ctorName(val)) {
          case 'Symbol':
            return 'symbol';
          case 'Promise':
            return 'promise';

          // Set, Map, WeakSet, WeakMap
          case 'WeakMap':
            return 'weakmap';
          case 'WeakSet':
            return 'weakset';
          case 'Map':
            return 'map';
          case 'Set':
            return 'set';

          // 8-bit typed arrays
          case 'Int8Array':
            return 'int8array';
          case 'Uint8Array':
            return 'uint8array';
          case 'Uint8ClampedArray':
            return 'uint8clampedarray';

          // 16-bit typed arrays
          case 'Int16Array':
            return 'int16array';
          case 'Uint16Array':
            return 'uint16array';

          // 32-bit typed arrays
          case 'Int32Array':
            return 'int32array';
          case 'Uint32Array':
            return 'uint32array';
          case 'Float32Array':
            return 'float32array';
          case 'Float64Array':
            return 'float64array';
        }

        if (isGeneratorObj(val)) {
          return 'generator';
        }

        // Non-plain objects
        type = toString.call(val);
        switch (type) {
          case '[object Object]':
            return 'object';
          // iterators
          case '[object Map Iterator]':
            return 'mapiterator';
          case '[object Set Iterator]':
            return 'setiterator';
          case '[object String Iterator]':
            return 'stringiterator';
          case '[object Array Iterator]':
            return 'arrayiterator';
        }

        // other
        return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
      };

      function ctorName(val) {
        return val.constructor ? val.constructor.name : null;
      }

      function isArray(val) {
        if (Array.isArray) return Array.isArray(val);
        return val instanceof Array;
      }

      function isError(val) {
        return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
      }

      function isDate(val) {
        if (val instanceof Date) return true;
        return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
      }

      function isRegexp(val) {
        if (val instanceof RegExp) return true;
        return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';
      }

      function isGeneratorFn(name, val) {
        return ctorName(name) === 'GeneratorFunction';
      }

      function isGeneratorObj(val) {
        return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';
      }

      function isArguments(val) {
        try {
          if (typeof val.length === 'number' && typeof val.callee === 'function') {
            return true;
          }
        } catch (err) {
          if (err.message.indexOf('callee') !== -1) {
            return true;
          }
        }
        return false;
      }

      /**
       * If you need to support Safari 5-7 (8-10 yr-old browser),
       * take a look at https://github.com/feross/is-buffer
       */

      function isBuffer(val) {
        if (val.constructor && typeof val.constructor.isBuffer === 'function') {
          return val.constructor.isBuffer(val);
        }
        return false;
      }

      /***/
    },
    /* 96 */
    /***/function (module, exports) {

      var toString = Object.prototype.toString;

      module.exports = function kindOf(val) {
        if (val === void 0) return 'undefined';
        if (val === null) return 'null';

        var type = typeof val === 'undefined' ? 'undefined' : _typeof2(val);
        if (type === 'boolean') return 'boolean';
        if (type === 'string') return 'string';
        if (type === 'number') return 'number';
        if (type === 'symbol') return 'symbol';
        if (type === 'function') {
          return isGeneratorFn(val) ? 'generatorfunction' : 'function';
        }

        if (isArray(val)) return 'array';
        if (isBuffer(val)) return 'buffer';
        if (isArguments(val)) return 'arguments';
        if (isDate(val)) return 'date';
        if (isError(val)) return 'error';
        if (isRegexp(val)) return 'regexp';

        switch (ctorName(val)) {
          case 'Symbol':
            return 'symbol';
          case 'Promise':
            return 'promise';

          // Set, Map, WeakSet, WeakMap
          case 'WeakMap':
            return 'weakmap';
          case 'WeakSet':
            return 'weakset';
          case 'Map':
            return 'map';
          case 'Set':
            return 'set';

          // 8-bit typed arrays
          case 'Int8Array':
            return 'int8array';
          case 'Uint8Array':
            return 'uint8array';
          case 'Uint8ClampedArray':
            return 'uint8clampedarray';

          // 16-bit typed arrays
          case 'Int16Array':
            return 'int16array';
          case 'Uint16Array':
            return 'uint16array';

          // 32-bit typed arrays
          case 'Int32Array':
            return 'int32array';
          case 'Uint32Array':
            return 'uint32array';
          case 'Float32Array':
            return 'float32array';
          case 'Float64Array':
            return 'float64array';
        }

        if (isGeneratorObj(val)) {
          return 'generator';
        }

        // Non-plain objects
        type = toString.call(val);
        switch (type) {
          case '[object Object]':
            return 'object';
          // iterators
          case '[object Map Iterator]':
            return 'mapiterator';
          case '[object Set Iterator]':
            return 'setiterator';
          case '[object String Iterator]':
            return 'stringiterator';
          case '[object Array Iterator]':
            return 'arrayiterator';
        }

        // other
        return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
      };

      function ctorName(val) {
        return val.constructor ? val.constructor.name : null;
      }

      function isArray(val) {
        if (Array.isArray) return Array.isArray(val);
        return val instanceof Array;
      }

      function isError(val) {
        return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
      }

      function isDate(val) {
        if (val instanceof Date) return true;
        return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
      }

      function isRegexp(val) {
        if (val instanceof RegExp) return true;
        return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';
      }

      function isGeneratorFn(name, val) {
        return ctorName(name) === 'GeneratorFunction';
      }

      function isGeneratorObj(val) {
        return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';
      }

      function isArguments(val) {
        try {
          if (typeof val.length === 'number' && typeof val.callee === 'function') {
            return true;
          }
        } catch (err) {
          if (err.message.indexOf('callee') !== -1) {
            return true;
          }
        }
        return false;
      }

      /**
       * If you need to support Safari 5-7 (8-10 yr-old browser),
       * take a look at https://github.com/feross/is-buffer
       */

      function isBuffer(val) {
        if (val.constructor && typeof val.constructor.isBuffer === 'function') {
          return val.constructor.isBuffer(val);
        }
        return false;
      }

      /***/
    },
    /* 97 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /*!
       * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
       *
       * Copyright (c) 2014-2017, Jon Schlinkert.
       * Released under the MIT License.
       */

      var isObject = __webpack_require__(98);

      function isObjectObject(o) {
        return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
      }

      module.exports = function isPlainObject(o) {
        var ctor, prot;

        if (isObjectObject(o) === false) return false;

        // If has modified constructor
        ctor = o.constructor;
        if (typeof ctor !== 'function') return false;

        // If has modified prototype
        prot = ctor.prototype;
        if (isObjectObject(prot) === false) return false;

        // If constructor does not have an Object-specific method
        if (prot.hasOwnProperty('isPrototypeOf') === false) {
          return false;
        }

        // Most likely a plain Object
        return true;
      };

      /***/
    },
    /* 98 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /*!
       * isobject <https://github.com/jonschlinkert/isobject>
       *
       * Copyright (c) 2014-2017, Jon Schlinkert.
       * Released under the MIT License.
       */

      module.exports = function isObject(val) {
        return val != null && (typeof val === 'undefined' ? 'undefined' : _typeof2(val)) === 'object' && Array.isArray(val) === false;
      };

      /***/
    },
    /* 99 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.callContextTypes = undefined;

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _ImpressionHandler = __webpack_require__(42);

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }return arr2;
        } else {
          return Array.from(arr);
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var callContextTypes = exports.callContextTypes = {
        frozenOrCalc: 'frozenValueOrOneTimeEval',
        oneTimeCalc: 'oneTimeEval',
        default: 'useFrozen'
      };

      var RoxVariant = function () {
        function RoxVariant(defaultValue, options, name) {
          _classCallCheck(this, RoxVariant);

          this._entityType = 'variant';
          this._validateDefault(defaultValue);
          if (Array.isArray(options)) {
            this._options = [].concat(_toConsumableArray(options));
            this._validateOptions();
            this._name = name;
          } else {
            this._options = [];
            if (options && typeof options === 'string') {
              this._name = options;
            }
          }
          if (this._options.indexOf(defaultValue) === -1) {
            this._options.push(defaultValue);
          }

          this._value = this._defaultValue = defaultValue;
          this._type = 'string';
          this._frozen = false;
          this._freezable = true;
        }

        _createClass(RoxVariant, [{
          key: '_validateDefault',
          value: function _validateDefault(defaultValue) {
            if (typeof defaultValue !== 'string') {
              throw new Error('RoxVariant default value must be string. Received \'' + defaultValue + '\'');
            }
          }
        }, {
          key: '_validateOptions',
          value: function _validateOptions() {
            var optionsError = new Error('RoxVariant options must be a non-empty array of strings. Received \'' + this._options + '\'');

            if (!this._options.every(function (option) {
              return typeof option === 'string';
            })) {
              throw optionsError;
            }
          }
        }, {
          key: 'getInternalValue',

          /* abstract */
          value: function getInternalValue() {
            throw Error('not implemented');
          }
        }, {
          key: '_getNameDetails',
          value: function _getNameDetails() {
            if (!this.name) return;
            var els = this.name.split('.');
            return {
              name: els.pop(),
              namespace: els.join('.') || 'default'
            };
          }
        }, {
          key: 'dump',
          value: function dump() {
            return {
              name: this.name,
              nameDetails: this._getNameDetails(),
              options: [].concat(_toConsumableArray(this._options)), //TODO: what about overrides?
              defaultValue: this.defaultValue,
              originalValue: this._originalValue(),
              overridingValue: this.overridenValue,
              value: this.getInternalValue({ dontInvokeFlagImpression: true, type: callContextTypes.frozenOrCalc })
            };
          }
        }, {
          key: '_originalValue',
          value: function _originalValue() {
            return this.getActiveValue({ dontInvokeFlagImpression: true, type: callContextTypes.frozenOrCalc });
          }
        }, {
          key: '_flagImpression',
          value: function _flagImpression(value, context) {
            (_ImpressionHandler.invokeImpression)(value, this, context);
          }
        }, {
          key: 'defaultValue',
          get: function get() {
            return this._defaultValue;
          }
        }, {
          key: 'overridenValue',
          get: function get() {
            if (this.overrider.hasOverride(this.name)) {
              return this.overrider.getOverride(this.name);
            }
          }
        }, {
          key: 'name',
          set: function set(name) {
            this._name = name;
          },
          get: function get() {
            return this._name;
          }
        }]);

        return RoxVariant;
      }();

      exports.default = RoxVariant;

      /***/
    },
    /* 100 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _RequestConfiguration = __webpack_require__(101);

      var _RequestConfigurationBuilder = __webpack_require__(102);

      var _parsers = __webpack_require__(4);

      var _setters = __webpack_require__(5);

      var _BugsnagReporter = __webpack_require__(13);

      var _BugsnagReporter2 = _interopRequireDefault(_BugsnagReporter);

      var _InternalFlags = __webpack_require__(21);

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      var _TargetGroupRepository = __webpack_require__(11);

      var _TargetGroupRepository2 = _interopRequireDefault(_TargetGroupRepository);

      var _ExperimentsRepository = __webpack_require__(3);

      var _ExperimentsRepository2 = _interopRequireDefault(_ExperimentsRepository);

      var _RoxFlagRepository = __webpack_require__(8);

      var _RoxFlagRepository2 = _interopRequireDefault(_RoxFlagRepository);

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      var _FetcherResults = __webpack_require__(46);

      var _EmbeddedConfiguration = __webpack_require__(103);

      var _EmbeddedConfiguration2 = _interopRequireDefault(_EmbeddedConfiguration);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var CACHE_KEY = _config2.default.get('CLIENT_DATA_CACHE_KEY');
      var isDispatchPeriodicallyRunning = false;

      var ConfigurationFetcher = function () {
        function ConfigurationFetcher(appKey, deviceProperties, devModeSecret, dependencies, embeddedPayload, options, networkOptions) {
          _classCallCheck(this, ConfigurationFetcher);

          this.cache = dependencies.RoxCache;
          this.crypto = dependencies.RoxCrypto;
          this.embdeddedJSON = this.fetchFromEmbedded(embeddedPayload);
          this.appKey = appKey;
          this.deviceProperties = deviceProperties;
          this.devModeSecret = devModeSecret;
          this.options = options || {};
          this.networkOptions = networkOptions;

          this.lastResponse = null;
        }

        _createClass(ConfigurationFetcher, [{
          key: 'runHandler',
          value: function runHandler(handler, data) {
            if (data.errorDetails) {
              _BugsnagReporter2.default.error('Configuration fetcher returned with ' + data.fetcherStatus, data.errorDetails);
            }
            if (handler instanceof Function) {
              try {
                handler(data);
              } catch (e) {}
            }
          }
        }, {
          key: 'dispatch',
          value: function dispatch(_ref) {
            var handler = _ref.handler,
                options = _ref.options;

            _RoxLogger2.default.debug('dispatch();');
            var sources = [];
            if (options.useCache) {
              if (this.embdeddedJSON) {
                var verified = this.verifyPayload(this.embdeddedJSON);
                if (!verified) {
                  throw new Error('The embdeddedJSON was corrupted or its authenticity cannot be securely verified.');
                }
                var embdeddedParser = this.parsePayload(this.embdeddedJSON);
                if (embdeddedParser) {
                  sources.push({
                    payload: this.embdeddedJSON,
                    parser: embdeddedParser,
                    status: _FetcherResults.FetcherStatus.APPLIED_FROM_EMBEDDED
                  });
                }
              }

              var cachedPayload = this.fetchFromCache();
              if (cachedPayload) {
                var _verified = this.verifyPayload(cachedPayload);
                if (!_verified) {
                  throw new Error('The cachedPayload was corrupted or its authenticity cannot be securely verified.');
                }
                var cachedParser = this.parsePayload(cachedPayload);
                if (cachedParser) {
                  sources.push({
                    payload: cachedPayload,
                    parser: cachedParser,
                    status: _FetcherResults.FetcherStatus.APPLIED_FROM_CACHE
                  });
                }
              }
            }

            if (sources.length > 0) {
              var latest = sources.reduce(function (latest, current) {
                return latest && latest.parser.signedDate() > current.parser.signedDate() ? latest : current;
              }, null);
              if (!this.lastApplied || this.lastApplied.signedDate() < latest.parser.signedDate()) {
                this.lastResponse = latest.payload;
                this.apply(latest.parser, latest.status, false, handler, latest.payload);
              }
            }

            if (options.skipNetwork) {
              return;
            }

            if (this.shouldSkipFetch(options.source)) {
              _RoxLogger2.default.debug('Skipping fetch - kill switch');
              return;
            }

            return this._dispatch({ handler: handler, storeInCache: true });
          }
        }, {
          key: 'shouldSkipFetch',
          value: function shouldSkipFetch(source) {
            var isFromPush = source === 'push';
            var timeBetweebFetches = (_InternalFlags.getNumber)('rox.internal.throttleFetchInSeconds');
            if (timeBetweebFetches > 0 && (!isFromPush || (_InternalFlags.isEnabled)('rox.internal.considerThrottleInPush'))) {
              var nowInMili = +Date.now();
              if (this.lastFetchTryTime && nowInMili < this.lastFetchTryTime + timeBetweebFetches * 1000) {
                return true;
              }

              this.lastFetchTryTime = nowInMili;
            }
            return false;
          }
        }, {
          key: 'dispatchPeriodically',
          value: function dispatchPeriodically(_ref2) {
            var _this = this;

            var handler = _ref2.handler,
                periodTimeInSec = _ref2.periodTimeInSec;

            if (isDispatchPeriodicallyRunning) {
              _RoxLogger2.default.debug('Dispatch Periodically already running');
              return Promise.resolve();
            }

            isDispatchPeriodicallyRunning = true;
            _RoxLogger2.default.debug('Dispatch Periodically');

            setInterval(function () {
              _this._dispatch({ handler: handler });
            }, periodTimeInSec * 1000);
          }
        }, {
          key: '_dispatch',
          value: function _dispatch(_ref3) {
            var _this2 = this;

            var handler = _ref3.handler,
                storeInCache = _ref3.storeInCache;

            return this.fetchFromNetwork().then(function (response) {
              var hasChanges = _this2.isNewResponse(response);
              var result = _this2.process(response, _FetcherResults.FetcherStatus.APPLIED_FROM_NETWORK, hasChanges, handler);
              return result.then(function () {
                storeInCache && _this2.storeInCache(response);
                _this2.lastResponse = response;
              });
            }).catch(function (err) {
              _this2.runHandler(handler, new _FetcherResults.FetcherResults(_FetcherResults.FetcherStatus.ERROR_FETCH_FAILED, null, false, err));
            });
          }
        }, {
          key: 'fetchFromNetwork',
          value: function fetchFromNetwork() {
            _RoxLogger2.default.debug('fetch from network for appKey ' + this.appKey);
            var rc = (_RequestConfigurationBuilder.buildRequestConfiguration)({
              appKey: this.appKey,
              deviceProperties: this.deviceProperties,
              devModeSecret: this.devModeSecret
            });

            if (this.options.roxyUrl) {
              return (_RequestConfiguration.fetchRemoteConfigurationWithRoxy)(rc, this.options.roxyUrl, this.networkOptions);
            }
            return (_RequestConfiguration.fetchRemoteConfiguration)(rc, this.networkOptions, this.options);
          }
        }, {
          key: 'fetchFromCache',
          value: function fetchFromCache() {
            _RoxLogger2.default.debug('fetch From Cache');
            var cached = this.cache.get(this.cacheKey());
            // handle legacy cacheKey (see ROL-556)
            if (!cached) {
              cached = this.cache.get(CACHE_KEY);
            }
            var parsed = void 0;
            if (cached) {
              try {
                parsed = JSON.parse(cached);
              } catch (e) {
                _RoxLogger2.default.warn('Configuration retrieved from cache, but is corrupted. Aborting. (Error: ' + e + ')');
              }
              if (parsed && parsed.constructor === Object) {
                _RoxLogger2.default.debug('Parsed cached = ' + JSON.stringify(parsed));
                return parsed;
              }
            }
          }
        }, {
          key: 'cacheKey',
          value: function cacheKey() {
            return CACHE_KEY + '-' + this.appKey;
          }
        }, {
          key: 'fetchFromEmbedded',
          value: function fetchFromEmbedded(embedded) {
            var parsed = void 0;
            if (embedded) {
              try {
                parsed = JSON.parse(embedded);
              } catch (e) {
                _RoxLogger2.default.warn('Received embdedded configuration, but it is corrupted. Aborting. Error: ', e);
              }
              if (parsed && parsed.constructor === Object) {
                _RoxLogger2.default.debug('Parsed embedded = ' + JSON.stringify(parsed));
                return parsed;
              }
            }
            if (_EmbeddedConfiguration2.default && (typeof _EmbeddedConfiguration2.default === 'undefined' ? 'undefined' : _typeof(_EmbeddedConfiguration2.default)) === 'object') {
              return _EmbeddedConfiguration2.default;
            }
          }
        }, {
          key: 'storeInCache',
          value: function storeInCache(response) {
            _RoxLogger2.default.debug('Store in cache response = ' + JSON.stringify(response));
            this.cache.set(this.cacheKey(), JSON.stringify(response));
          }
        }, {
          key: 'process',
          value: function process(payload, source, hasChanges, handler) {
            if (!payload) {
              return Promise.reject('Empty configuration');
            }
            var verified = this.verifyPayload(payload);
            if (!verified) {
              throw new Error('The payload has corrupted or its authenticity cannot be securely verified.');
            }
            var parser = this.parsePayload(payload);
            if (!parser) {
              return Promise.reject('Failed to parse configuration');
            }
            return this.apply(parser, source, hasChanges, handler, payload);
          }
        }, {
          key: 'apply',
          value: function apply(parser, source, hasChanges, handler, clientData) {
            var _this3 = this;

            if (parser) {
              this.calculatePayload(parser);
              this.lastApplied = parser;
              return new Promise(function (resolve) {
                var fetcherResults = new _FetcherResults.FetcherResults(source, parser.signedDate(), hasChanges, undefined, clientData);
                _this3.runHandler(handler, fetcherResults);
                resolve();
              });
            }
          }
        }, {
          key: 'parsePayload',
          value: function parsePayload(response) {
            var validateAppKey = !this.options.roxyUrl;
            var parser = new _parsers.ConfigurationParser(response, this.appKey, validateAppKey);
            if (!parser.parse()) {
              _RoxLogger2.default.debug('failed to parse payload. response = ' + JSON.stringify(response) + ' deviceProps = ' + this.deviceProperties + ' app_key = ' + this.appKey);
              return null;
            }
            return parser;
          }
        }, {
          key: 'verifyPayload',
          value: function verifyPayload(response) {
            var signature_v0 = response.signature_v0,
                data = response.data;

            if (this.options.roxyUrl || this.options.selfManagedMode) {
              return true;
            }

            return this.crypto.verify(data, signature_v0);
          }
        }, {
          key: 'calculatePayload',
          value: function calculatePayload(parser) {
            if (!parser) {
              return;
            }

            _TargetGroupRepository2.default.setTargetGroups(parser.targetGroups());
            _ExperimentsRepository2.default.setExperiments(parser.experiments());

            new _setters.ConfigurationSetter().prepareConfigurations(parser.remoteConfigurations());
            new _setters.FlagsSetter(_RoxFlagRepository2.default, _ExperimentsRepository2.default).prepareFlagsWithExperiments();

            return parser;
          }
        }, {
          key: 'isNewResponse',
          value: function isNewResponse(response) {
            return JSON.stringify(this.lastResponse) !== JSON.stringify(response);
          }
        }]);

        return ConfigurationFetcher;
      }();

      exports.default = ConfigurationFetcher;

      /***/
    },
    /* 101 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fetchRemoteConfigurationWithRoxy = fetchRemoteConfigurationWithRoxy;
      exports.fetchRemoteConfiguration = fetchRemoteConfiguration;

      var _RoxAPI = __webpack_require__(43);

      var _NetworkDispatcher = __webpack_require__(44);

      var _RoxLogger = __webpack_require__(1);

      var _RoxLogger2 = _interopRequireDefault(_RoxLogger);

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function catchRejection(request) {
        return request.catch(function (err) {
          err.message = 'Unable to fetch rox configuration!\n' + err.message;
          _RoxLogger2.default.error(err);
          throw err;
        });
      }

      function fetchRemoteConfigurationWithRoxy(properties, endpoint, networkOptions) {
        var apiRequestData = (_RoxAPI.buildAPIURL)(properties, endpoint);

        var request = (_NetworkDispatcher.fetchFromRoxyAPI)(apiRequestData.url, networkOptions);
        return catchRejection(request);
      }

      function fetchRemoteConfiguration(properties, networkOptions) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var cache_url = properties.cache_url + '?distinct_id=' + properties.distinct_id;

        if (options.selfManagedMode && !_config2.default.get('CD_S3_ENDPOINT')) {
          var apiRequestData = (_RoxAPI.buildAPIURL)(properties);
          return catchRejection((_NetworkDispatcher.fetchFromAPI)(apiRequestData.url, apiRequestData.body, networkOptions));
        }
        var request = (_NetworkDispatcher.fetchFromCDN)(cache_url, networkOptions).catch(function () {
          var apiRequestData = (_RoxAPI.buildAPIURL)(properties);
          return (_NetworkDispatcher.fetchFromAPI)(apiRequestData.url, apiRequestData.body, networkOptions);
        });
        return catchRejection(request);
      }

      /***/
    },
    /* 102 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildRequestConfiguration = undefined;

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      var _Md5Generator = __webpack_require__(45);

      var Md5Generator = _interopRequireWildcard(_Md5Generator);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var buildRequestConfiguration = exports.buildRequestConfiguration = function buildRequestConfiguration(_ref) {
        var appKey = _ref.appKey,
            deviceProperties = _ref.deviceProperties,
            devModeSecret = _ref.devModeSecret;

        var properties = deviceProperties.getProperties();

        properties.app_key = appKey;

        properties.buid = Md5Generator.generateBuid(properties);
        properties.buid_generators_list = Md5Generator.BUID_GENERATOR_LIST.join(',');
        properties.relative_url = appKey + '/' + properties.buid;
        properties.cache_url = '' + _config2.default.get('CD_S3_ENDPOINT') + properties.relative_url;

        properties.devModeSecret = devModeSecret;

        return properties;
      };

      /***/
    },
    /* 103 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _data = void 0,
          _tmp = void 0;
      try {
        _tmp = ($__ROX_EMBEDDED_CONTENT);
      } catch (e) {}
      if (_tmp && typeof _tmp === 'string') {
        try {
          _tmp = JSON.parse(_tmp);
        } catch (e) {
          _tmp = undefined;
        }
      }
      if (_tmp && _tmp.constructor === Object && _tmp.signed_date) {
        _data = _tmp;
      }
      exports.default = _data;

      /***/
    },
    /* 104 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _repositories = __webpack_require__(6);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var defaultOptions = { flagsRepository: _repositories.Flags, configurationRepository: _repositories.Configuration };

      var RoxClassRegister = function () {
        function RoxClassRegister() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, RoxClassRegister);

          this.options = Object.assign({}, defaultOptions, options);
          this._flagsRepository = this.options.flagsRepository;
          this._configurationRepository = this.options.configurationRepository;
          this._namespaceStore = new Set();
        }

        _createClass(RoxClassRegister, [{
          key: 'handleContainer',
          value: function handleContainer(namespace, container) {
            if (Object.prototype.toString.call(namespace) !== '[object String]') {
              throw new Error('InvalidNamespace: Namespace must be a string (non-nullable).');
            }
            if (this._namespaceStore.has(namespace)) {
              var err = 'InvalidNamespace: A namespace must be unique. A container with the given namespace (\'' + namespace + '\') has already been registered.';
              throw new Error(err);
            } else {
              this._namespaceStore.add(namespace);
            }
            for (var prop in container) {
              if (container.hasOwnProperty(prop)) {
                var label = namespace ? namespace + '.' + prop : prop;
                var entity = container[prop];
                if (entity._entityType === 'flag' || entity._entityType === 'variant') {
                  this._flagsRepository.addFlag(label, entity);
                }
                if (entity._entityType === 'configuration') {
                  this._configurationRepository.addRemoteConfiguration(label, entity);
                }
              }
            }
          }
        }]);

        return RoxClassRegister;
      }();

      exports.default = RoxClassRegister;

      /***/
    },
    /* 105 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var DeviceProperties = function () {
        function DeviceProperties(cache, uuid) {
          _classCallCheck(this, DeviceProperties);

          this.cache = cache;
          this._uuid = uuid;
          this.distinct_id = this.generateDistinctId();
          this.app_release = '0.0';
          this.distinctIdSetExplicitly = false;
        }

        _createClass(DeviceProperties, [{
          key: 'setPlatform',
          value: function setPlatform(platform) {
            this.platform = platform;
          }
        }, {
          key: 'setDistinctId',
          value: function setDistinctId(id) {
            this.distinctIdSetExplicitly = true;
            this.distinct_id = id;
          }
        }, {
          key: 'setAppRelease',
          value: function setAppRelease(appRelease) {
            this.app_release = appRelease;
          }
        }, {
          key: 'uuid',
          value: function uuid() {
            return this._uuid();
          }
        }, {
          key: 'generateDistinctId',
          value: function generateDistinctId() {
            var distinct_id = this.cache.get('distinctId');
            if (!distinct_id) {
              distinct_id = this.uuid();
              this.cache.set('distinctId', distinct_id);
            }
            return distinct_id;
          }
        }]);

        return DeviceProperties;
      }();

      exports.default = DeviceProperties;

      /***/
    },
    /* 106 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Client = undefined;

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      exports.default = function () {
        var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _deps = Object.assign({}, _deps, deps);

        instance._dynamicApi = new _DynamicApi2.default(deps.EntitiesProvider, _repositories.Flags, instance);
        return instance;
      };

      var _ = __webpack_require__(9);

      var _repositories = __webpack_require__(6);

      var _DynamicApi = __webpack_require__(48);

      var _DynamicApi2 = _interopRequireDefault(_DynamicApi);

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      var _entities = __webpack_require__(20);

      var _parsers = __webpack_require__(4);

      var _ImpressionHandler = __webpack_require__(42);

      var _Analytics = __webpack_require__(107);

      var _Analytics2 = _interopRequireDefault(_Analytics);

      var _notification_listener = __webpack_require__(108);

      var _notification_listener2 = _interopRequireDefault(_notification_listener);

      var _InternalFlags = __webpack_require__(21);

      var _DynamicProperties = __webpack_require__(25);

      var _debounce = __webpack_require__(115);

      var _debounce2 = _interopRequireDefault(_debounce);

      var _FetcherResults = __webpack_require__(46);

      var _StateSender = __webpack_require__(124);

      var _StateSender2 = _interopRequireDefault(_StateSender);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var MINIMUM_INTERVAL_SEC = 30;
      var DISABLED_INTERVAL_THRESOLD = 0;
      var SEND_STATE_DEBOUNCE_TIMEOUT_MS = 5000;

      var _deps = {
        ClassRegister: _.ClassRegister
      };

      var Client = exports.Client = function () {
        function Client() {
          var _this = this;

          var sendStateDebounceTimeoutMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SEND_STATE_DEBOUNCE_TIMEOUT_MS;

          _classCallCheck(this, Client);

          this.classRegisterer = new _deps.ClassRegister();

          this.sendStateDebounceNoCheck = (_debounce2.default)(function () {
            _this._sendState();
          }, sendStateDebounceTimeoutMs, {
            maxWait: sendStateDebounceTimeoutMs,
            leading: false,
            trailing: true
          });
          this.sendStateDebounced = function () {
            if (_this.appKey) {
              _this.sendStateDebounceNoCheck();
            }
          };
          this.onConfigurationFetched = this.onConfigurationFetched.bind(this);
        }

        _createClass(Client, [{
          key: 'setKey',
          value: function setKey(apiKey) {
            if (/^[a-f\d]{24}$/i.test(apiKey)) {
              this.app_key = apiKey;
            } else {
              throw Error('invalid rollout apikey');
            }
          }
        }, {
          key: 'setup',
          value: function setup() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            try {
              // Bootstrap Options
              this.handleOptions(options);

              // Bootstrap Device Properties
              _deps.DeviceProperties = _deps.DeviceProperties.create ? _deps.DeviceProperties.create(_deps) : _deps.DeviceProperties;
              this.app_release && _deps.DeviceProperties.setAppRelease(this.app_release);
              this.distinct_id && _deps.DeviceProperties.setDistinctId(this.distinct_id);
              this.platform && _deps.DeviceProperties.setPlatform(this.platform);
              this.deviceProperties = _deps.DeviceProperties;

              // Bootstrap Error Reporter
              _.BugsnagReporter.init(this.appKey, _deps.DeviceProperties, this.networkOptions, this.selfManagedMode);

              // Bootstap Configuration Fetcher
              this.configurationFetcher = new _.ConfigurationFetcher(this.appKey, this.deviceProperties, this.devModeSecret, _deps, this.embeddedConfiguration, { roxyUrl: this.roxyUrl, selfManagedMode: this.selfManagedMode }, this.networkOptions);

              if (!this.roxyUrl) {
                this.stateSender = new _StateSender2.default(this.appKey, this.deviceProperties, this.devModeSecret, this.networkOptions, { selfManagedMode: this.selfManagedMode });
                if (!this.disableNetwork) {
                  (_ImpressionHandler.setAnalytics)(new _Analytics2.default(this.appKey, Object.assign({}, this.analyticsOptions), _deps.DeviceProperties, this.networkOptions));
                }
              }

              // Bootstrap Custom Properties
              _deps.getDefaultCustomProperties(this.deviceProperties, this.appKey).map(_repositories.CustomProperties.setIfNotExists.bind(_repositories.CustomProperties));
            } catch (e) {
              var message = 'Oh uh! An error occured during setup.';
              _.RoxLogger.error(message, e);
              _.BugsnagReporter.error(message, e);
            }
            return Promise.resolve(this);
          }
        }, {
          key: 'handleOptions',
          value: function handleOptions(options) {
            var _options = Object.assign({}, _deps.DefaultSetupOptions, options);
            if (_options.selfManaged && _typeof(_options.selfManaged) === 'object') {
              if (!_options.selfManaged.analyticsURL) {
                throw new Error('analyticsURL is required on self managed mode');
              } else if (!_options.selfManaged.serverURL) {
                throw new Error('serverURL is required on self managed mode');
              }
              if (options.selfManaged.configurationURL) {
                _options.selfManaged.configurationURL = options.selfManaged.configurationURL.endsWith('/') ? options.selfManaged.configurationURL : options.selfManaged.configurationURL + '/';
              }
              if (options.selfManaged.stateURL) {
                _options.selfManaged.stateURL = options.selfManaged.stateURL.endsWith('/') ? options.selfManaged.stateURL : options.selfManaged.stateURL + '/';
              }
              _config2.default.setSelfManagedMode(_options.selfManaged);
              (_InternalFlags.setDefaultsMode)(true);
              this.selfManagedMode = true;
            }
            if (_options.configuration && _options.configuration.disableNetwork) {
              this.disableNetwork = true;
            }
            this.embeddedConfiguration = _options.embedded;
            this.fetchIntervalInSec = _options.fetchIntervalInSec;
            this.disablePushUpdateListener = this.disableNetwork || this.selfManagedMode && !_options.selfManaged.pushUpdateURL ? true : _options.disablePushUpdateListener;
            this.configurationFetchedHandler = _options.configurationFetchedHandler;
            this.impressionHandler = _options.impressionHandler;
            this.app_release = _options.version;
            this.distinct_id = _options.distinctId;
            this.devModeSecret = _options.devModeSecret;
            this.platform = _options.platform;
            this.roxyUrl = _options.roxy;
            this.networkOptions = {
              httpAgent: _options.httpAgent,
              httpsAgent: _options.httpsAgent
            };
            this.analyticsOptions = _options.analytics;
            this.eventSourceImpl = _options.eventSourceImpl;
            this.notificationEndpoint = _options.configuration && _options.configuration.NOTIFICATIONS_ENDPOINT ? _options.configuration.NOTIFICATIONS_ENDPOINT : _config2.default.get('NOTIFICATIONS_ENDPOINT');
            (_ImpressionHandler.setHandler)(this.impressionHandler);
            if (options.logger) {
              _.RoxLogger.setLogger(options.logger);
            }
          }
        }, {
          key: 'fetchPeriodically',
          value: function fetchPeriodically() {
            if (!this.app_key) {
              _.RoxLogger.warn('no app key');
              return Promise.reject();
            }
            if (this.fetchIntervalInSec <= DISABLED_INTERVAL_THRESOLD) return Promise.resolve();
            if (this.fetchIntervalInSec < MINIMUM_INTERVAL_SEC) this.fetchIntervalInSec = MINIMUM_INTERVAL_SEC;
            var fetchPromise = this._fetch({ useCache: false });
            this.configurationFetcher.dispatchPeriodically({
              handler: this.onConfigurationFetched,
              periodTimeInSec: this.fetchIntervalInSec
            });
            return fetchPromise;
          }
        }, {
          key: 'fetchCacheOnly',
          value: function fetchCacheOnly() {
            return this._fetch({ useCache: true, skipNetwork: true });
          }
        }, {
          key: 'fetchWithCacheAndProceed',
          value: function fetchWithCacheAndProceed() {
            return this._fetch({ useCache: true });
          }
        }, {
          key: 'fetch',
          value: function fetch() {
            return this._fetch({ useCache: false });
          }
        }, {
          key: '_fetchFromPush',
          value: function _fetchFromPush() {
            return this._fetch({ useCache: false, source: 'push' });
          }
        }, {
          key: 'sendState',
          value: function sendState() {
            this._sendState();
          }
        }, {
          key: '_sendState',
          value: function _sendState() {
            this.sendStateDebounceNoCheck.cancel();

            if (!this.app_key) {
              return;
            }
            if (this.disableNetwork) {
              _.RoxLogger.debug('send state - disabled network');
              return;
            }
            if (this.stateSender) {
              this.stateSender.send();
            }
          }
        }, {
          key: '_fetch',
          value: function _fetch() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!this.app_key) {
              _.RoxLogger.warn('no app key');
              return;
            }
            if (!this.configurationFetcher) {
              return;
            }
            if (this.disableNetwork) {
              _.RoxLogger.debug('fetch - disabling network');
              options.skipNetwork = true;
            }

            return this.configurationFetcher.dispatch({
              handler: this.onConfigurationFetched,
              options: options
            });
          }
        }, {
          key: 'register',
          value: function register(name, container) {
            _.RoxLogger.debug('Registering container \'' + name + '\' = ' + JSON.stringify(container));
            this.classRegisterer.handleContainer(name, container);
            this.sendStateDebounced();
          }
        }, {
          key: 'setCustomProperty',
          value: function setCustomProperty(name, type, value) {
            var property = new _entities.CustomProperty(name, type, value);
            var isNew = !_repositories.CustomProperties.has(property);
            _repositories.CustomProperties.set(property);
            isNew && this.sendStateDebounced();
          }
        }, {
          key: 'unfreeze',
          value: function unfreeze(namespace, freezeLevel) {
            var namespaceFilter = function namespaceFilter(flag) {
              if (!flag.name || typeof namespace !== 'string') return true;
              var flagNameParts = flag.name.split('.');
              if (flagNameParts.length === 1 && namespace === '') {
                return true;
              } else if (flagNameParts.slice(0, flagNameParts.length - 1).join('.') === namespace) {
                return true;
              }

              return false;
            };
            _repositories.Flags.flags.filter(namespaceFilter).forEach(function (flag) {
              flag.unfreeze(freezeLevel);
            });

            _repositories.Configuration.remoteConfigurations.filter(namespaceFilter).forEach(function (remoteConfiguration) {
              remoteConfiguration.unfreeze(freezeLevel);
            });
          }
        }, {
          key: 'onConfigurationFetched',
          value: function onConfigurationFetched(data) {
            try {
              if (data.fetcherStatus !== _FetcherResults.FetcherStatus.ERROR_FETCH_FAILED) {
                this.startOrStopPushUpdatesListener();
              }
            } catch (ex) {
              _.RoxLogger.warn('Cound not start or stop push notification listener. exception: ' + ex);
            }

            if (this.configurationFetchedHandler instanceof Function) {
              try {
                return this.configurationFetchedHandler(data);
              } catch (e) {}
            }
          }
        }, {
          key: 'startOrStopPushUpdatesListener',
          value: function startOrStopPushUpdatesListener() {
            var _this2 = this;

            if (!this.disablePushUpdateListener && (_InternalFlags.isEnabled)('rox.internal.pushUpdates')) {
              if (this.app_key) {
                if (!this.pushUpdatesListener) {
                  this.pushUpdatesListener = new _notification_listener2.default(this.notificationEndpoint, this.app_key, this.eventSourceImpl);
                  this.pushUpdatesListener.on('changed', function () {
                    _this2._fetchFromPush();
                  });
                }
              }
            } else {
              if (this.pushUpdatesListener) {
                this.pushUpdatesListener.stop();
                this.pushUpdatesListener = null;
              }
            }
          }
        }, {
          key: 'setDynamicCustomPropertyRule',
          value: function setDynamicCustomPropertyRule(handler) {
            (_DynamicProperties.setDynamicPropertyHandler)(handler);
          }
        }, {
          key: 'dynamicApi',
          get: function get() {
            return this._dynamicApi;
          }
        }, {
          key: 'appKey',
          get: function get() {
            return this.app_key;
          }
        }, {
          key: 'metadata',
          get: function get() {
            var _roxxTrueToBoolean = function _roxxTrueToBoolean(val) {
              return val === 'true' ? true : false;
            };

            var parser = new _parsers.RoxxParser();
            var targetGroups = _repositories.TargetGroups.targetGroups.map(function (tg) {
              return {
                name: tg.name,
                isEnabled: parser.evaluateExpression(tg.condition)
              };
            });
            var experiments = _repositories.Experiments.experiments.map(function (e) {
              return {
                name: e.name,
                isEnabled: _roxxTrueToBoolean(parser.evaluateExpression(e.deploymentConfiguration.condition))
              };
            });
            var remoteConfigurations = _repositories.Configuration.remoteConfigurations.map(function (c) {
              return {
                name: c.name,
                value: c.value
              };
            });
            var flags = _repositories.Flags.flags.map(function (f) {
              return {
                name: f.name,
                value: f._peek()
              };
            });

            return { targetGroups: targetGroups, experiments: experiments, remoteConfigurations: remoteConfigurations, flags: flags };
          }
        }]);

        return Client;
      }();

      var instance = new Client();

      /***/
    },
    /* 107 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }(); /*
           MIT License
           Copyright © 2017 Segment Inc. <friends@segment.com>
           Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
           The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
           THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
           */

      /* eslint-disable prettier/prettier */

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var axios = __webpack_require__(14).create();

      var setImmediate = function setImmediate(callback) {
        setTimeout(callback, 5);
      };
      var noop = function noop() {};

      var Analytics = function () {
        /**
         * Initialize a new `Analytics` with your Segment project's `writeKey` and an
         * optional dictionary of `options`.
         *
         * @param {String} writeKey
         * @param {Object} [options] (optional)
         *   @property {Number} flushAt (default: 20)
         *   @property {Number} flushInterval (default: 10000)
         *   @property {String} host (default: 'https://api.segment.io')
         *   @property {Boolean} enable (default: true)
         * @param deviceProperties
         * @param networkOptions (axios options, see https://github.com/axios/axios#request-config)
         */

        function Analytics(writeKey, options, deviceProperties, networkOptions) {
          _classCallCheck(this, Analytics);

          options = options || {};

          this.queue = [];
          this.writeKey = writeKey;
          this.host = options.host || _config2.default.get('ANALYTICS_ENDPOINT');
          this.timeout = options.timeout || false;
          this.flushAt = Math.max(options.flushAt || 20, 1);
          this.flushInterval = options.flushInterval || 10000;
          this.flushed = false;
          this.version = deviceProperties.getProperties().lib_version || '0.0';
          if (typeof deviceProperties.getProperties().platform === 'undefined') {
            throw new Error('Platform must be provided');
          }
          this.platform = deviceProperties.getProperties().platform || '';
          this.networkOptions = networkOptions;
          Object.defineProperty(this, 'enable', {
            configurable: false,
            writable: false,
            enumerable: true,
            value: typeof options.enable === 'boolean' ? options.enable : true
          });
        }

        /**
         * Send an identify `message`.
         *
         * @param {Object} message
         * @param {Function} [callback] (optional)
         * @return {Analytics}
         */

        _createClass(Analytics, [{
          key: 'identify',
          value: function identify(message, callback) {
            this.enqueue('identify', message, callback);
            return this;
          }

          /**
           * Send a group `message`.
           *
           * @param {Object} message
           * @param {Function} [callback] (optional)
           * @return {Analytics}
           */

        }, {
          key: 'group',
          value: function group(message, callback) {
            this.enqueue('group', message, callback);
            return this;
          }

          /**
           * Send a track `message`.
           *
           * @param {Object} message
           * @param {Function} [callback] (optional)
           * @return {Analytics}
           */

        }, {
          key: 'track',
          value: function track(message, callback) {
            this.enqueue('track', message, callback);
            return this;
          }

          /**
           * Send a page `message`.
           *
           * @param {Object} message
           * @param {Function} [callback] (optional)
           * @return {Analytics}
           */

        }, {
          key: 'page',
          value: function page(message, callback) {
            this.enqueue('page', message, callback);
            return this;
          }

          /**
           * Send a screen `message`.
           *
           * @param {Object} message
           * @param {Function} fn (optional)
           * @return {Analytics}
           */

        }, {
          key: 'screen',
          value: function screen(message, callback) {
            this.enqueue('screen', message, callback);
            return this;
          }

          /**
           * Send an alias `message`.
           *
           * @param {Object} message
           * @param {Function} [callback] (optional)
           * @return {Analytics}
           */

        }, {
          key: 'alias',
          value: function alias(message, callback) {
            this.enqueue('alias', message, callback);
            return this;
          }

          /**
           * Add a `message` of type `type` to the queue and
           * check whether it should be flushed.
           *
           * @param {String} type
           * @param {Object} message
           * @param {Function} [callback] (optional)
           * @api private
           */

        }, {
          key: 'enqueue',
          value: function enqueue(type, message, callback) {
            callback = callback || noop;

            if (!this.enable) {
              return setImmediate(callback);
            }

            message = Object.assign({}, message);

            this.queue.push({ message: message, callback: callback });

            if (!this.flushed) {
              this.flushed = true;
              this.flush();
              return;
            }

            if (this.queue.length >= this.flushAt) {
              this.flush();
            }

            if (this.flushInterval && !this.timer) {
              this.timer = setTimeout(this.flush.bind(this), this.flushInterval);
            }
          }

          /**
           * Flush the current queue
           *
           * @param {Function} [callback] (optional)
           * @return {Analytics}
           */

        }, {
          key: 'flush',
          value: function flush(callback) {
            callback = callback || noop;

            if (!this.enable) {
              return setImmediate(callback);
            }

            if (this.timer) {
              clearTimeout(this.timer);
              this.timer = null;
            }

            if (!this.queue.length) {
              return setImmediate(callback);
            }

            var items = this.queue.splice(0, this.flushAt);
            var callbacks = items.map(function (item) {
              return item.callback;
            });
            var messages = items.map(function (item) {
              return item.message;
            });

            var data = {
              analyticsVersion: '1.0.0',
              sdkVersion: this.version,
              time: new Date().getTime(),
              platform: this.platform,
              rolloutKey: this.writeKey,
              events: messages
            };

            var done = function done(err) {
              callbacks.forEach(function (callback) {
                return callback(err);
              });
              callback(err, data);
            };

            var req = {
              method: 'POST',
              url: this.host + '/impression/' + this.writeKey,
              data: data,
              // might use ...networkOptions if need more options
              httpsAgent: this.networkOptions.httpsAgent,
              httpAgent: this.networkOptions.httpAgent
            };

            if (this.timeout) {
              req.timeout = this.timeout;
            }

            axios(req).then(function () {
              return done();
            }).catch(function (err) {
              if (err.response) {
                var error = new Error(err.response.statusText);
                return done(error);
              }

              done(err);
            });
          }
        }]);

        return Analytics;
      }();

      exports.default = Analytics;

      /***/
    },
    /* 108 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
      };

      var _eventsource = __webpack_require__(109);

      var _eventsource2 = _interopRequireDefault(_eventsource);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var EventSource = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.EventSource ? window.EventSource : _eventsource2.default;

      var NotificationListener = function () {
        function NotificationListener(listenUrl, app_key, eventSourceImpl) {
          _classCallCheck(this, NotificationListener);

          var sseUrl = '' + listenUrl + (listenUrl.endsWith('/') ? '' : '/') + app_key;
          this.eventSource = eventSourceImpl ? new eventSourceImpl(sseUrl) : new EventSource(sseUrl);
        }

        _createClass(NotificationListener, [{
          key: 'on',
          value: function on(eventName, handler) {
            this.eventSource.addEventListener(eventName, function (event) {
              try {
                handler(event);
              } catch (e) {}
            });
          }
        }, {
          key: 'stop',
          value: function stop() {
            this.eventSource.close();
          }
        }]);

        return NotificationListener;
      }();

      exports.default = NotificationListener;

      /***/
    },
    /* 109 */
    /***/function (module, exports, __webpack_require__) {

      var original = __webpack_require__(110);
      var parse = __webpack_require__(19).parse;
      var events$$1 = __webpack_require__(114);
      var https$$1 = __webpack_require__(18);
      var http$$1 = __webpack_require__(17);
      var util$$1 = __webpack_require__(34);

      var httpsOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'];

      var bom = [239, 187, 191];
      var colon = 58;
      var space = 32;
      var lineFeed = 10;
      var carriageReturn = 13;

      function hasBom(buf) {
        return bom.every(function (charCode, index) {
          return buf[index] === charCode;
        });
      }

      /**
       * Creates a new EventSource object
       *
       * @param {String} url the URL to which to connect
       * @param {Object} [eventSourceInitDict] extra init params. See README for details.
       * @api public
       **/
      function EventSource(url$$1, eventSourceInitDict) {
        var readyState = EventSource.CONNECTING;
        Object.defineProperty(this, 'readyState', {
          get: function get() {
            return readyState;
          }
        });

        Object.defineProperty(this, 'url', {
          get: function get() {
            return url$$1;
          }
        });

        var self = this;
        self.reconnectInterval = 1000;

        function onConnectionClosed(message) {
          if (readyState === EventSource.CLOSED) return;
          readyState = EventSource.CONNECTING;
          _emit('error', new Event('error', { message: message }));

          // The url may have been changed by a temporary
          // redirect. If that's the case, revert it now.
          if (reconnectUrl) {
            url$$1 = reconnectUrl;
            reconnectUrl = null;
          }
          setTimeout(function () {
            if (readyState !== EventSource.CONNECTING) {
              return;
            }
            connect();
          }, self.reconnectInterval);
        }

        var req;
        var lastEventId = '';
        if (eventSourceInitDict && eventSourceInitDict.headers && eventSourceInitDict.headers['Last-Event-ID']) {
          lastEventId = eventSourceInitDict.headers['Last-Event-ID'];
          delete eventSourceInitDict.headers['Last-Event-ID'];
        }

        var discardTrailingNewline = false;
        var data = '';
        var eventName = '';

        var reconnectUrl = null;

        function connect() {
          var options = parse(url$$1);
          var isSecure = options.protocol === 'https:';
          options.headers = { 'Cache-Control': 'no-cache', 'Accept': 'text/event-stream' };
          if (lastEventId) options.headers['Last-Event-ID'] = lastEventId;
          if (eventSourceInitDict && eventSourceInitDict.headers) {
            for (var i in eventSourceInitDict.headers) {
              var header = eventSourceInitDict.headers[i];
              if (header) {
                options.headers[i] = header;
              }
            }
          }

          // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,
          // but for now exists as a backwards-compatibility layer
          options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);

          // If specify http proxy, make the request to sent to the proxy server,
          // and include the original url in path and Host headers
          var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
          if (useProxy) {
            var proxy = parse(eventSourceInitDict.proxy);
            isSecure = proxy.protocol === 'https:';

            options.protocol = isSecure ? 'https:' : 'http:';
            options.path = url$$1;
            options.headers.Host = options.host;
            options.hostname = proxy.hostname;
            options.host = proxy.host;
            options.port = proxy.port;
          }

          // If https options are specified, merge them into the request options
          if (eventSourceInitDict && eventSourceInitDict.https) {
            for (var optName in eventSourceInitDict.https) {
              if (httpsOptions.indexOf(optName) === -1) {
                continue;
              }

              var option = eventSourceInitDict.https[optName];
              if (option !== undefined) {
                options[optName] = option;
              }
            }
          }

          // Pass this on to the XHR
          if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {
            options.withCredentials = eventSourceInitDict.withCredentials;
          }

          req = (isSecure ? https$$1 : http$$1).request(options, function (res) {
            // Handle HTTP errors
            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
              _emit('error', new Event('error', { status: res.statusCode, message: res.statusMessage }));
              onConnectionClosed();
              return;
            }

            // Handle HTTP redirects
            if (res.statusCode === 301 || res.statusCode === 307) {
              if (!res.headers.location) {
                // Server sent redirect response without Location header.
                _emit('error', new Event('error', { status: res.statusCode, message: res.statusMessage }));
                return;
              }
              if (res.statusCode === 307) reconnectUrl = url$$1;
              url$$1 = res.headers.location;
              process.nextTick(connect);
              return;
            }

            if (res.statusCode !== 200) {
              _emit('error', new Event('error', { status: res.statusCode, message: res.statusMessage }));
              return self.close();
            }

            readyState = EventSource.OPEN;
            res.on('close', function () {
              res.removeAllListeners('close');
              res.removeAllListeners('end');
              onConnectionClosed();
            });

            res.on('end', function () {
              res.removeAllListeners('close');
              res.removeAllListeners('end');
              onConnectionClosed();
            });
            _emit('open', new Event('open'));

            // text/event-stream parser adapted from webkit's
            // Source/WebCore/page/EventSource.cpp
            var isFirst = true;
            var buf;
            res.on('data', function (chunk) {
              buf = buf ? Buffer.concat([buf, chunk]) : chunk;
              if (isFirst && hasBom(buf)) {
                buf = buf.slice(bom.length);
              }

              isFirst = false;
              var pos = 0;
              var length = buf.length;

              while (pos < length) {
                if (discardTrailingNewline) {
                  if (buf[pos] === lineFeed) {
                    ++pos;
                  }
                  discardTrailingNewline = false;
                }

                var lineLength = -1;
                var fieldLength = -1;
                var c;

                for (var i = pos; lineLength < 0 && i < length; ++i) {
                  c = buf[i];
                  if (c === colon) {
                    if (fieldLength < 0) {
                      fieldLength = i - pos;
                    }
                  } else if (c === carriageReturn) {
                    discardTrailingNewline = true;
                    lineLength = i - pos;
                  } else if (c === lineFeed) {
                    lineLength = i - pos;
                  }
                }

                if (lineLength < 0) {
                  break;
                }

                parseEventStreamLine(buf, pos, fieldLength, lineLength);

                pos += lineLength + 1;
              }

              if (pos === length) {
                buf = void 0;
              } else if (pos > 0) {
                buf = buf.slice(pos);
              }
            });
          });

          req.on('error', function (err) {
            onConnectionClosed(err.message);
          });

          if (req.setNoDelay) req.setNoDelay(true);
          req.end();
        }

        connect();

        function _emit() {
          if (self.listeners(arguments[0]).length > 0) {
            self.emit.apply(self, arguments);
          }
        }

        this._close = function () {
          if (readyState === EventSource.CLOSED) return;
          readyState = EventSource.CLOSED;
          if (req.abort) req.abort();
          if (req.xhr && req.xhr.abort) req.xhr.abort();
        };

        function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
          if (lineLength === 0) {
            if (data.length > 0) {
              var type = eventName || 'message';
              _emit(type, new MessageEvent(type, {
                data: data.slice(0, -1), // remove trailing newline
                lastEventId: lastEventId,
                origin: original(url$$1)
              }));
              data = '';
            }
            eventName = void 0;
          } else if (fieldLength > 0) {
            var noValue = fieldLength < 0;
            var step = 0;
            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();

            if (noValue) {
              step = lineLength;
            } else if (buf[pos + fieldLength + 1] !== space) {
              step = fieldLength + 1;
            } else {
              step = fieldLength + 2;
            }
            pos += step;

            var valueLength = lineLength - step;
            var value = buf.slice(pos, pos + valueLength).toString();

            if (field === 'data') {
              data += value + '\n';
            } else if (field === 'event') {
              eventName = value;
            } else if (field === 'id') {
              lastEventId = value;
            } else if (field === 'retry') {
              var retry = parseInt(value, 10);
              if (!Number.isNaN(retry)) {
                self.reconnectInterval = retry;
              }
            }
          }
        }
      }

      module.exports = EventSource;

      util$$1.inherits(EventSource, events$$1.EventEmitter);
      EventSource.prototype.constructor = EventSource; // make stacktraces readable

      ['open', 'error', 'message'].forEach(function (method) {
        Object.defineProperty(EventSource.prototype, 'on' + method, {
          /**
           * Returns the current listener
           *
           * @return {Mixed} the set function or undefined
           * @api private
           */
          get: function get() {
            var listener = this.listeners(method)[0];
            return listener ? listener._listener ? listener._listener : listener : undefined;
          },

          /**
           * Start listening for events
           *
           * @param {Function} listener the listener
           * @return {Mixed} the set function or undefined
           * @api private
           */
          set: function set(listener) {
            this.removeAllListeners(method);
            this.addEventListener(method, listener);
          }
        });
      });

      /**
       * Ready states
       */
      Object.defineProperty(EventSource, 'CONNECTING', { enumerable: true, value: 0 });
      Object.defineProperty(EventSource, 'OPEN', { enumerable: true, value: 1 });
      Object.defineProperty(EventSource, 'CLOSED', { enumerable: true, value: 2 });

      EventSource.prototype.CONNECTING = 0;
      EventSource.prototype.OPEN = 1;
      EventSource.prototype.CLOSED = 2;

      /**
       * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close
       * @api public
       */
      EventSource.prototype.close = function () {
        this._close();
      };

      /**
       * Emulates the W3C Browser based WebSocket interface using addEventListener.
       *
       * @param {String} type A string representing the event type to listen out for
       * @param {Function} listener callback
       * @see https://developer.mozilla.org/en/DOM/element.addEventListener
       * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
       * @api public
       */
      EventSource.prototype.addEventListener = function addEventListener(type, listener) {
        if (typeof listener === 'function') {
          // store a reference so we can return the original function again
          listener._listener = listener;
          this.on(type, listener);
        }
      };

      /**
       * Emulates the W3C Browser based WebSocket interface using dispatchEvent.
       *
       * @param {Event} event An event to be dispatched
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
       * @api public
       */
      EventSource.prototype.dispatchEvent = function dispatchEvent(event) {
        if (!event.type) {
          throw new Error('UNSPECIFIED_EVENT_TYPE_ERR');
        }
        // if event is instance of an CustomEvent (or has 'details' property),
        // send the detail object as the payload for the event
        this.emit(event.type, event.detail);
      };

      /**
       * Emulates the W3C Browser based WebSocket interface using removeEventListener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {Function} listener callback
       * @see https://developer.mozilla.org/en/DOM/element.removeEventListener
       * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
       * @api public
       */
      EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {
        if (typeof listener === 'function') {
          listener._listener = undefined;
          this.removeListener(type, listener);
        }
      };

      /**
       * W3C Event
       *
       * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event
       * @api private
       */
      function Event(type, optionalProperties) {
        Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true });
        if (optionalProperties) {
          for (var f in optionalProperties) {
            if (optionalProperties.hasOwnProperty(f)) {
              Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true });
            }
          }
        }
      }

      /**
       * W3C MessageEvent
       *
       * @see http://www.w3.org/TR/webmessaging/#event-definitions
       * @api private
       */
      function MessageEvent(type, eventInitDict) {
        Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true });
        for (var f in eventInitDict) {
          if (eventInitDict.hasOwnProperty(f)) {
            Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true });
          }
        }
      }

      /***/
    },
    /* 110 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var parse = __webpack_require__(111);

      /**
       * Transform an URL to a valid origin value.
       *
       * @param {String|Object} url URL to transform to it's origin.
       * @returns {String} The origin.
       * @api public
       */
      function origin(url$$1) {
        if ('string' === typeof url$$1) url$$1 = parse(url$$1);

        //
        // 6.2.  ASCII Serialization of an Origin
        // http://tools.ietf.org/html/rfc6454#section-6.2
        //
        if (!url$$1.protocol || !url$$1.hostname) return 'null';

        //
        // 4. Origin of a URI
        // http://tools.ietf.org/html/rfc6454#section-4
        //
        // States that url.scheme, host should be converted to lower case. This also
        // makes it easier to match origins as everything is just lower case.
        //
        return (url$$1.protocol + '//' + url$$1.host).toLowerCase();
      }

      /**
       * Check if the origins are the same.
       *
       * @param {String} a URL or origin of a.
       * @param {String} b URL or origin of b.
       * @returns {Boolean}
       * @api public
       */
      origin.same = function same(a, b) {
        return origin(a) === origin(b);
      };

      //
      // Expose the origin
      //
      module.exports = origin;

      /***/
    },
    /* 111 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var required = __webpack_require__(112),
          qs = __webpack_require__(113),
          slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
          protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i,
          whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]',
          left = new RegExp('^' + whitespace + '+');

      /**
       * Trim a given string.
       *
       * @param {String} str String to trim.
       * @public
       */
      function trimLeft(str) {
        return (str ? str : '').toString().replace(left, '');
      }

      /**
       * These are the parse rules for the URL parser, it informs the parser
       * about:
       *
       * 0. The char it Needs to parse, if it's a string it should be done using
       *    indexOf, RegExp using exec and NaN means set as current value.
       * 1. The property we should set when parsing this value.
       * 2. Indication if it's backwards or forward parsing, when set as number it's
       *    the value of extra chars that should be split off.
       * 3. Inherit from location if non existing in the parser.
       * 4. `toLowerCase` the resulting value.
       */
      var rules = [['#', 'hash'], // Extract from the back.
      ['?', 'query'], // Extract from the back.
      function sanitize(address) {
        // Sanitize what is left of the address
        return address.replace('\\', '/');
      }, ['/', 'pathname'], // Extract from the back.
      ['@', 'auth', 1], // Extract from the front.
      [NaN, 'host', undefined, 1, 1], // Set left over value.
      [/:(\d+)$/, 'port', undefined, 1], // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1] // Set left over.
      ];

      /**
       * These properties should not be copied or inherited from. This is only needed
       * for all non blob URL's as a blob URL does not include a hash, only the
       * origin.
       *
       * @type {Object}
       * @private
       */
      var ignore = { hash: 1, query: 1 };

      /**
       * The location object differs when your code is loaded through a normal page,
       * Worker or through a worker using a blob. And with the blobble begins the
       * trouble as the location object will contain the URL of the blob, not the
       * location of the page where our code is loaded in. The actual origin is
       * encoded in the `pathname` so we can thankfully generate a good "default"
       * location from it so we can generate proper relative URL's again.
       *
       * @param {Object|String} loc Optional default location object.
       * @returns {Object} lolcation object.
       * @public
       */
      function lolcation(loc) {
        var globalVar;

        if (typeof window !== 'undefined') globalVar = window;else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;else if (typeof self !== 'undefined') globalVar = self;else globalVar = {};

        var location = globalVar.location || {};
        loc = loc || location;

        var finaldestination = {},
            type = typeof loc === 'undefined' ? 'undefined' : _typeof2(loc),
            key;

        if ('blob:' === loc.protocol) {
          finaldestination = new Url(unescape(loc.pathname), {});
        } else if ('string' === type) {
          finaldestination = new Url(loc, {});
          for (key in ignore) {
            delete finaldestination[key];
          }
        } else if ('object' === type) {
          for (key in loc) {
            if (key in ignore) continue;
            finaldestination[key] = loc[key];
          }

          if (finaldestination.slashes === undefined) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }

        return finaldestination;
      }

      /**
       * @typedef ProtocolExtract
       * @type Object
       * @property {String} protocol Protocol matched in the URL, in lowercase.
       * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
       * @property {String} rest Rest of the URL that is not part of the protocol.
       */

      /**
       * Extract protocol information from a URL with/without double slash ("//").
       *
       * @param {String} address URL we want to extract from.
       * @return {ProtocolExtract} Extracted information.
       * @private
       */
      function extractProtocol(address) {
        address = trimLeft(address);
        var match = protocolre.exec(address);

        return {
          protocol: match[1] ? match[1].toLowerCase() : '',
          slashes: !!match[2],
          rest: match[3]
        };
      }

      /**
       * Resolve a relative URL pathname against a base URL pathname.
       *
       * @param {String} relative Pathname of the relative URL.
       * @param {String} base Pathname of the base URL.
       * @return {String} Resolved pathname.
       * @private
       */
      function resolve(relative, base) {
        if (relative === '') return base;

        var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
            i = path.length,
            last = path[i - 1],
            unshift = false,
            up = 0;

        while (i--) {
          if (path[i] === '.') {
            path.splice(i, 1);
          } else if (path[i] === '..') {
            path.splice(i, 1);
            up++;
          } else if (up) {
            if (i === 0) unshift = true;
            path.splice(i, 1);
            up--;
          }
        }

        if (unshift) path.unshift('');
        if (last === '.' || last === '..') path.push('');

        return path.join('/');
      }

      /**
       * The actual URL instance. Instead of returning an object we've opted-in to
       * create an actual constructor as it's much more memory efficient and
       * faster and it pleases my OCD.
       *
       * It is worth noting that we should not use `URL` as class name to prevent
       * clashes with the global URL instance that got introduced in browsers.
       *
       * @constructor
       * @param {String} address URL we want to parse.
       * @param {Object|String} [location] Location defaults for relative paths.
       * @param {Boolean|Function} [parser] Parser for the query string.
       * @private
       */
      function Url(address, location, parser) {
        address = trimLeft(address);

        if (!(this instanceof Url)) {
          return new Url(address, location, parser);
        }

        var relative,
            extracted,
            parse,
            instruction,
            index,
            key,
            instructions = rules.slice(),
            type = typeof location === 'undefined' ? 'undefined' : _typeof2(location),
            url$$1 = this,
            i = 0;

        //
        // The following if statements allows this module two have compatibility with
        // 2 different API:
        //
        // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
        //    where the boolean indicates that the query string should also be parsed.
        //
        // 2. The `URL` interface of the browser which accepts a URL, object as
        //    arguments. The supplied object will be used as default values / fall-back
        //    for relative paths.
        //
        if ('object' !== type && 'string' !== type) {
          parser = location;
          location = null;
        }

        if (parser && 'function' !== typeof parser) parser = qs.parse;

        location = lolcation(location);

        //
        // Extract protocol information before running the instructions.
        //
        extracted = extractProtocol(address || '');
        relative = !extracted.protocol && !extracted.slashes;
        url$$1.slashes = extracted.slashes || relative && location.slashes;
        url$$1.protocol = extracted.protocol || location.protocol || '';
        address = extracted.rest;

        //
        // When the authority component is absent the URL starts with a path
        // component.
        //
        if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

        for (; i < instructions.length; i++) {
          instruction = instructions[i];

          if (typeof instruction === 'function') {
            address = instruction(address);
            continue;
          }

          parse = instruction[0];
          key = instruction[1];

          if (parse !== parse) {
            url$$1[key] = address;
          } else if ('string' === typeof parse) {
            if (~(index = address.indexOf(parse))) {
              if ('number' === typeof instruction[2]) {
                url$$1[key] = address.slice(0, index);
                address = address.slice(index + instruction[2]);
              } else {
                url$$1[key] = address.slice(index);
                address = address.slice(0, index);
              }
            }
          } else if (index = parse.exec(address)) {
            url$$1[key] = index[1];
            address = address.slice(0, index.index);
          }

          url$$1[key] = url$$1[key] || (relative && instruction[3] ? location[key] || '' : '');

          //
          // Hostname, host and protocol should be lowercased so they can be used to
          // create a proper `origin`.
          //
          if (instruction[4]) url$$1[key] = url$$1[key].toLowerCase();
        }

        //
        // Also parse the supplied query string in to an object. If we're supplied
        // with a custom parser as function use that instead of the default build-in
        // parser.
        //
        if (parser) url$$1.query = parser(url$$1.query);

        //
        // If the URL is relative, resolve the pathname against the base URL.
        //
        if (relative && location.slashes && url$$1.pathname.charAt(0) !== '/' && (url$$1.pathname !== '' || location.pathname !== '')) {
          url$$1.pathname = resolve(url$$1.pathname, location.pathname);
        }

        //
        // We should not add port numbers if they are already the default port number
        // for a given protocol. As the host also contains the port number we're going
        // override it with the hostname which contains no port number.
        //
        if (!required(url$$1.port, url$$1.protocol)) {
          url$$1.host = url$$1.hostname;
          url$$1.port = '';
        }

        //
        // Parse down the `auth` for the username and password.
        //
        url$$1.username = url$$1.password = '';
        if (url$$1.auth) {
          instruction = url$$1.auth.split(':');
          url$$1.username = instruction[0] || '';
          url$$1.password = instruction[1] || '';
        }

        url$$1.origin = url$$1.protocol && url$$1.host && url$$1.protocol !== 'file:' ? url$$1.protocol + '//' + url$$1.host : 'null';

        //
        // The href is just the compiled result.
        //
        url$$1.href = url$$1.toString();
      }

      /**
       * This is convenience method for changing properties in the URL instance to
       * insure that they all propagate correctly.
       *
       * @param {String} part          Property we need to adjust.
       * @param {Mixed} value          The newly assigned value.
       * @param {Boolean|Function} fn  When setting the query, it will be the function
       *                               used to parse the query.
       *                               When setting the protocol, double slash will be
       *                               removed from the final url if it is true.
       * @returns {URL} URL instance for chaining.
       * @public
       */
      function set(part, value, fn) {
        var url$$1 = this;

        switch (part) {
          case 'query':
            if ('string' === typeof value && value.length) {
              value = (fn || qs.parse)(value);
            }

            url$$1[part] = value;
            break;

          case 'port':
            url$$1[part] = value;

            if (!required(value, url$$1.protocol)) {
              url$$1.host = url$$1.hostname;
              url$$1[part] = '';
            } else if (value) {
              url$$1.host = url$$1.hostname + ':' + value;
            }

            break;

          case 'hostname':
            url$$1[part] = value;

            if (url$$1.port) value += ':' + url$$1.port;
            url$$1.host = value;
            break;

          case 'host':
            url$$1[part] = value;

            if (/:\d+$/.test(value)) {
              value = value.split(':');
              url$$1.port = value.pop();
              url$$1.hostname = value.join(':');
            } else {
              url$$1.hostname = value;
              url$$1.port = '';
            }

            break;

          case 'protocol':
            url$$1.protocol = value.toLowerCase();
            url$$1.slashes = !fn;
            break;

          case 'pathname':
          case 'hash':
            if (value) {
              var char = part === 'pathname' ? '/' : '#';
              url$$1[part] = value.charAt(0) !== char ? char + value : value;
            } else {
              url$$1[part] = value;
            }
            break;

          default:
            url$$1[part] = value;
        }

        for (var i = 0; i < rules.length; i++) {
          var ins = rules[i];

          if (ins[4]) url$$1[ins[1]] = url$$1[ins[1]].toLowerCase();
        }

        url$$1.origin = url$$1.protocol && url$$1.host && url$$1.protocol !== 'file:' ? url$$1.protocol + '//' + url$$1.host : 'null';

        url$$1.href = url$$1.toString();

        return url$$1;
      }

      /**
       * Transform the properties back in to a valid and full URL string.
       *
       * @param {Function} stringify Optional query stringify function.
       * @returns {String} Compiled version of the URL.
       * @public
       */
      function toString(stringify) {
        if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

        var query,
            url$$1 = this,
            protocol = url$$1.protocol;

        if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

        var result = protocol + (url$$1.slashes ? '//' : '');

        if (url$$1.username) {
          result += url$$1.username;
          if (url$$1.password) result += ':' + url$$1.password;
          result += '@';
        }

        result += url$$1.host + url$$1.pathname;

        query = 'object' === _typeof2(url$$1.query) ? stringify(url$$1.query) : url$$1.query;
        if (query) result += '?' !== query.charAt(0) ? '?' + query : query;

        if (url$$1.hash) result += url$$1.hash;

        return result;
      }

      Url.prototype = { set: set, toString: toString };

      //
      // Expose the URL parser and some additional properties that might be useful for
      // others or testing.
      //
      Url.extractProtocol = extractProtocol;
      Url.location = lolcation;
      Url.trimLeft = trimLeft;
      Url.qs = qs;

      module.exports = Url;

      /***/
    },
    /* 112 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      /**
       * Check if we're required to add a port number.
       *
       * @see https://url.spec.whatwg.org/#default-port
       * @param {Number|String} port Port number we need to check
       * @param {String} protocol Protocol we need to check against.
       * @returns {Boolean} Is it a default port for the given protocol
       * @api private
       */

      module.exports = function required(port, protocol) {
        protocol = protocol.split(':')[0];
        port = +port;

        if (!port) return false;

        switch (protocol) {
          case 'http':
          case 'ws':
            return port !== 80;

          case 'https':
          case 'wss':
            return port !== 443;

          case 'ftp':
            return port !== 21;

          case 'gopher':
            return port !== 70;

          case 'file':
            return false;
        }

        return port !== 0;
      };

      /***/
    },
    /* 113 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      var has = Object.prototype.hasOwnProperty,
          undef;

      /**
       * Decode a URI encoded string.
       *
       * @param {String} input The URI encoded string.
       * @returns {String|Null} The decoded string.
       * @api private
       */
      function decode(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, ' '));
        } catch (e) {
          return null;
        }
      }

      /**
       * Attempts to encode a given input.
       *
       * @param {String} input The string that needs to be encoded.
       * @returns {String|Null} The encoded string.
       * @api private
       */
      function querystring(query) {
        var parser = /([^=?&]+)=?([^&]*)/g,
            result = {},
            part;

        while (part = parser.exec(query)) {
          var key = decode(part[1]),
              value = decode(part[2]);

          //
          // Prevent overriding of existing properties. This ensures that build-in
          // methods like `toString` or __proto__ are not overriden by malicious
          // querystrings.
          //
          // In the case if failed decoding, we want to omit the key/value pairs
          // from the result.
          //
          if (key === null || value === null || key in result) continue;
          result[key] = value;
        }

        return result;
      }

      /**
       * Transform a query string to an object.
       *
       * @param {Object} obj Object that should be transformed.
       * @param {String} prefix Optional prefix.
       * @returns {String}
       * @api public
       */
      function querystringify(obj, prefix) {
        prefix = prefix || '';

        var pairs = [],
            value,
            key;

        //
        // Optionally prefix with a '?' if needed
        //
        if ('string' !== typeof prefix) prefix = '?';

        for (key in obj) {
          if (has.call(obj, key)) {
            value = obj[key];

            //
            // Edge cases where we actually want to encode the value to an empty
            // string instead of the stringified value.
            //
            if (!value && (value === null || value === undef || isNaN(value))) {
              value = '';
            }

            key = encodeURIComponent(key);
            value = encodeURIComponent(value);

            //
            // If we failed to encode the strings, we should bail out as we don't
            // want to add invalid strings to the query.
            //
            if (key === null || value === null) continue;
            pairs.push(key + '=' + value);
          }
        }

        return pairs.length ? prefix + pairs.join('&') : '';
      }

      //
      // Expose the module.
      //
      exports.stringify = querystringify;
      exports.parse = querystring;

      /***/
    },
    /* 114 */
    /***/function (module, exports) {

      module.exports = events;

      /***/
    },
    /* 115 */
    /***/function (module, exports, __webpack_require__) {

      var isObject = __webpack_require__(49),
          now = __webpack_require__(116),
          toNumber = __webpack_require__(118);

      /** Error message constants. */
      var FUNC_ERROR_TEXT = 'Expected a function';

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max,
          nativeMin = Math.min;

      /**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */
      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          // Reset any `maxWait` timer.
          lastInvokeTime = time;
          // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
          // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              result = wait - timeSinceLastCall;

          return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.
          return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }

        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              // Handle invocations in a tight loop.
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      module.exports = debounce;

      /***/
    },
    /* 116 */
    /***/function (module, exports, __webpack_require__) {

      var root = __webpack_require__(50);

      /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */
      var now = function now() {
        return root.Date.now();
      };

      module.exports = now;

      /***/
    },
    /* 117 */
    /***/function (module, exports) {

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = (typeof commonjsGlobal === 'undefined' ? 'undefined' : _typeof2(commonjsGlobal)) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

      module.exports = freeGlobal;

      /***/
    },
    /* 118 */
    /***/function (module, exports, __webpack_require__) {

      var isObject = __webpack_require__(49),
          isSymbol = __webpack_require__(119);

      /** Used as references for various `Number` constants. */
      var NAN = 0 / 0;

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Built-in method references without a dependency on `root`. */
      var freeParseInt = parseInt;

      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }

      module.exports = toNumber;

      /***/
    },
    /* 119 */
    /***/function (module, exports, __webpack_require__) {

      var baseGetTag = __webpack_require__(120),
          isObjectLike = __webpack_require__(123);

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]';

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }

      module.exports = isSymbol;

      /***/
    },
    /* 120 */
    /***/function (module, exports, __webpack_require__) {

      var _Symbol2 = __webpack_require__(51),
          getRawTag = __webpack_require__(121),
          objectToString = __webpack_require__(122);

      /** `Object#toString` result references. */
      var nullTag = '[object Null]',
          undefinedTag = '[object Undefined]';

      /** Built-in value references. */
      var symToStringTag = _Symbol2 ? _Symbol2.toStringTag : undefined;

      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }

      module.exports = baseGetTag;

      /***/
    },
    /* 121 */
    /***/function (module, exports, __webpack_require__) {

      var _Symbol3 = __webpack_require__(51);

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /** Built-in value references. */
      var symToStringTag = _Symbol3 ? _Symbol3.toStringTag : undefined;

      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }

      module.exports = getRawTag;

      /***/
    },
    /* 122 */
    /***/function (module, exports) {

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      module.exports = objectToString;

      /***/
    },
    /* 123 */
    /***/function (module, exports) {

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof2(value)) == 'object';
      }

      module.exports = isObjectLike;

      /***/
    },
    /* 124 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _SetState = __webpack_require__(125);

      var _Md5Generator = __webpack_require__(45);

      var Md5Generator = _interopRequireWildcard(_Md5Generator);

      var _ = __webpack_require__(9);

      var _RuntimeRegistry = __webpack_require__(47);

      var _RuntimeRegistry2 = _interopRequireDefault(_RuntimeRegistry);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }newObj.default = obj;return newObj;
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var registry = new _RuntimeRegistry2.default();

      var StateSender = function () {
        function StateSender(appKey, deviceProperties, devModeSecret, networkOptions, options) {
          _classCallCheck(this, StateSender);

          this.appKey = appKey;
          this.deviceProperties = deviceProperties;
          this.devModeSecret = devModeSecret;
          this.networkOptions = networkOptions;
          this.options = options;
        }

        _createClass(StateSender, [{
          key: 'send',
          value: function send() {
            _.RoxLogger.debug('check for cached state for appKey ' + this.appKey);
            var ssData = this.buildSetState();

            try {
              (_SetState.sendStateNetwork)(ssData, this.networkOptions, this.options);
            } catch (error) {
              _.RoxLogger.error('failed to send state', error);
            }
          }
        }, {
          key: 'sortItemsByName',
          value: function sortItemsByName(arr) {
            return arr.sort(function (item1, item2) {
              return item1.name > item2.name ? -1 : 1;
            });
          }
        }, {
          key: 'buildSetState',
          value: function buildSetState() {
            var properties = this.deviceProperties.getProperties();

            properties.app_key = this.appKey;

            properties.feature_flags = this.sortItemsByName(registry.featureFlags);
            properties.custom_properties = this.sortItemsByName(registry.customProperties);
            properties.remoteVariables = this.sortItemsByName(registry.remoteConfiguration);
            properties.devModeSecret = this.devModeSecret;

            properties.md5 = Md5Generator.generateStateMd5(properties);

            return properties;
          }
        }]);

        return StateSender;
      }();

      exports.default = StateSender;

      /***/
    },
    /* 125 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sendStateNetwork = sendStateNetwork;

      var _NetworkDispatcher = __webpack_require__(44);

      var _RoxAPI = __webpack_require__(43);

      var _config = __webpack_require__(2);

      var _config2 = _interopRequireDefault(_config);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function catchRejection(request) {
        return request.catch(function (err) {
          err.message = 'Unable to send state!\n' + err.message;
          throw err;
        });
      }

      function sendStateNetwork(properties, networkOptions) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var state_url = (_RoxAPI.buildSetStateS3URL)(properties);

        if (options.selfManagedMode && !_config2.default.get('SS_S3_ENDPOINT')) {
          var apiRequestData = (_RoxAPI.buildSetStateAPIURL)(properties);
          return catchRejection((_NetworkDispatcher.setStateToAPI)(apiRequestData.url, apiRequestData.body, networkOptions));
        }
        var request = (_NetworkDispatcher.stateFromCDN)(state_url, networkOptions).catch(function () {
          var apiRequestData = (_RoxAPI.buildSetStateAPIURL)(properties);
          return (_NetworkDispatcher.setStateToAPI)(apiRequestData.url, apiRequestData.body, networkOptions);
        });
        return catchRejection(request);
      }

      /***/
    },
    /* 126 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();

      var _TargetGroup = __webpack_require__(41);

      var _TargetGroup2 = _interopRequireDefault(_TargetGroup);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var terms = {
        TARGET_GROUP_ID: '_id',
        TARGET_GROUP_CONDITION: 'condition'
      };

      var TargetGroupsParser = function () {
        function TargetGroupsParser(json) {
          _classCallCheck(this, TargetGroupsParser);

          this._json = json;
        }

        _createClass(TargetGroupsParser, [{
          key: 'parse',
          value: function parse() {
            if (!this._json || !this._json.length) {
              return [];
            }

            var targetGroups = [];

            this._json.forEach(function (json) {
              if (!json || !json[terms.TARGET_GROUP_ID] || !json[terms.TARGET_GROUP_CONDITION]) {
                return;
              }
              targetGroups.push(new _TargetGroup2.default(json[terms.TARGET_GROUP_ID], json[terms.TARGET_GROUP_CONDITION]));
            });

            return targetGroups;
          }
        }]);

        return TargetGroupsParser;
      }();

      exports.default = TargetGroupsParser;

      /***/
    }]
    /******/)["default"]
  );
});

});

var roxBase$1 = unwrapExports(roxBase);

var version = "4.9.7";








var ROX = {"api_version":"1.8.0"};

var Manifest = {
  api_version: ROX.api_version,
  lib_version: version
};

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RoxCache = function () {
  function RoxCache() {
    _classCallCheck$2(this, RoxCache);
  }

  _createClass$2(RoxCache, [{
    key: "set",
    value: function set() {}
  }, {
    key: "get",
    value: function get() {}
  }]);

  return RoxCache;
}();

var RoxCache$1 = new RoxCache();

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.



var rng = function nodeRNG() {
  return crypto.randomBytes(16);
};

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DevicePropertiesBase = roxBase$1.DeviceProperties;
var api_version = Manifest.api_version;
var lib_version = Manifest.lib_version;

var DeviceProperties = function (_DevicePropertiesBase) {
  _inherits(DeviceProperties, _DevicePropertiesBase);

  function DeviceProperties() {
    _classCallCheck$1(this, DeviceProperties);

    return _possibleConstructorReturn(this, (DeviceProperties.__proto__ || Object.getPrototypeOf(DeviceProperties)).apply(this, arguments));
  }

  _createClass$1(DeviceProperties, [{
    key: 'getProperties',
    value: function getProperties() {
      var distinct_id = this.distinct_id,
          app_release = this.app_release,
          platform = this.platform;

      return {
        app_release: app_release,
        api_version: api_version,
        lib_version: lib_version,
        distinct_id: distinct_id,
        platform: platform,
        customSigningCertificate: '5659eb0ca47811395ef85f0b09be63b7',
        anticache: +Date.now()
      };
    }
  }]);

  return DeviceProperties;
}(DevicePropertiesBase);

var DeviceProperties$1 = new DeviceProperties(RoxCache$1, v4_1);

var defaultSetupOptions = {
  distinctId: null,
  version: '0',
  configurationFetchedHandler: function configurationFetchedHandler() {},
  impressionHandler: null,
  fetchIntervalInSec: 60,
  devModeSecret: null,
  platform: 'NodeJS'
};

var CustomProperty = roxBase$1.Entities.CustomProperty;


function getDefaultCustomProperties(deviceProps, appKey) {
  var distinctId = deviceProps.distinct_id;
  if (!deviceProps.distinctIdSetExplicitly) {
    distinctId = function distinctId(context) {
      return deviceProps.generateDistinctId();
    }; // eslint-disable-line no-unused-vars
  }
  var _props = deviceProps.getProperties();

  return [new CustomProperty('rox.app_release', String, _props.app_release), new CustomProperty('rox.platform', String, _props.platform), new CustomProperty('rox.distinct_id', String, distinctId), new CustomProperty('rox.internal.realPlatform', String, 'NodeJS'), new CustomProperty('rox.internal.customPlatform', String, _props.platform), new CustomProperty('rox.internal.appKey', String, appKey), new CustomProperty('rox.internal.distinct_id', String, function () {
    return v4_1();
  })];
}

var publicKey = '-----BEGIN RSA PUBLIC KEY-----\n\
MIIBCgKCAQEA6vBjERS8mkFQxHXB5WJuzZxqwKoSz9hP9u1ttck0Hop+6/BTk/+4\n\
ydDy6XBi8P98w0+cMyCdzrRcuB1q3toZ+8JrfmyPm20v/ZCq5qpKYwI9fj8JweJY\n\
RGndu5aJTArs+abq6ottPZO6udSDHX6tPzrez/wZqfiwTbNheIzLD2MWVFGJFUwJ\n\
j6oJ8MblqCWWp/zhjY7Y/ThoPHjnDn3MsQuBg0f2GopfpIbeCPxx3rEl1bpKl57b\n\
G3YJ1yhZF+vNk7hT3N6XfJcvujejklqWzVfFJhFWcoJ8Vk978QU9k1rxXsW1udij\n\
hWPdcCJI7fiDxDDyQTzw4jfSdp7rbb3zKQIDAQAB\n\
-----END RSA PUBLIC KEY-----';

var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_HASH_FUNC = 'SHA256';
var DEFAULT_SIGNATURE_ENCODING = 'base64';
var DEFAULT_PAYLOAD_ENCODING = 'utf-8';

var RoxCrypto = function () {
  function RoxCrypto() {
    _classCallCheck$3(this, RoxCrypto);
  }

  _createClass$3(RoxCrypto, null, [{
    key: 'verify',
    value: function verify(payload) {
      var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var hash_algo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_HASH_FUNC;

      if (payload.constructor !== String) {
        payload = JSON.stringify(payload);
      }
      var verifier = crypto.createVerify(hash_algo);
      verifier.update(payload, DEFAULT_PAYLOAD_ENCODING);
      var result = verifier.verify(publicKey, signature, DEFAULT_SIGNATURE_ENCODING);
      return result;
    }
  }]);

  return RoxCrypto;
}();

var OVERRIDE_CACHE_KEY = 'roxOverrideValues';

var cache = RoxCache$1.get(OVERRIDE_CACHE_KEY);
if (!cache) {
  cache = {};
} else {
  cache = JSON.parse(cache);
}

function writeCache(cache) {
  RoxCache$1.set(OVERRIDE_CACHE_KEY, JSON.stringify(cache));
}

function hasOverride() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (typeof name === 'undefined') return false;
  return typeof cache[name] !== 'undefined';
}

function getOverride() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (!name) throw new Error('Missing name');
  return cache[name];
}

function setOverride(name, value) {
  if (!name) throw new Error('Missing name');
  cache[name] = value;
  writeCache(cache);
}

function clearOverride(name) {
  if (!name) throw new Error('Missing name');
  cache[name] = undefined;
  delete cache[name];
  writeCache(cache);
}

function clearAllOverrides() {
  cache = {};
  writeCache(cache);
}

function getOriginalValue(name) {
  if (!name) throw new Error('Missing name');
  var flag = roxBase$1.Repositories.Flags.flagWithName(name);
  if (!flag) return null;
  return flag._originalValue();
}

var Overrider = Object.freeze({
	hasOverride: hasOverride,
	getOverride: getOverride,
	setOverride: setOverride,
	clearOverride: clearOverride,
	clearAllOverrides: clearAllOverrides,
	getOriginalValue: getOriginalValue
});

var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseVariant = roxBase$1.Entities.Variant;
var RoxxParser = roxBase$1.Parsers.RoxxParser;

var Context = roxBase$1.Context;

var parser = new RoxxParser();

var Variant = function (_BaseVariant) {
  _inherits$1(Variant, _BaseVariant);

  function Variant(defaultValue, options, name) {
    _classCallCheck$5(this, Variant);

    var _this = _possibleConstructorReturn$1(this, (Variant.__proto__ || Object.getPrototypeOf(Variant)).call(this, defaultValue, options, name));

    _this._freezable = false;
    return _this;
  }

  _createClass$5(Variant, [{
    key: 'getActiveValue',
    value: function getActiveValue(callContext, context) {
      if (this.condition) {
        var mergedContext = Context.Actions.getMergedContextWithGlobal(context);
        var evaluatedResult = parser.evaluateExpression(this.condition, callContext, mergedContext);
        var castedResult = evaluatedResult && evaluatedResult.toString ? evaluatedResult.toString() : evaluatedResult;

        if (typeof castedResult !== 'undefined') {
          callContext.isExperimenting = true;
          callContext.dontInvokeFlagImpression || this._flagImpression(castedResult, context);
          return castedResult;
        }
      }
      callContext.dontInvokeFlagImpression || this._flagImpression(this._defaultValue, context);
      return this._defaultValue;
    }
  }, {
    key: 'getInternalValue',
    value: function getInternalValue(callContext, context) {
      var overridenValue = this.overridenValue;
      if (overridenValue) {
        callContext.isExperimenting = true;
        return overridenValue;
      }

      return this.getActiveValue(callContext, context);
    }
  }, {
    key: 'getValue',
    value: function getValue(context) {
      return this.getInternalValue({}, context);
    }
  }, {
    key: 'peek',
    value: function peek(context) {
      var callContext = { dontInvokeFlagImpression: true };
      return this.getInternalValue(callContext, context);
    }
  }, {
    key: 'overrider',
    get: function get() {
      return Overrider;
    }
  }]);

  return Variant;
}(BaseVariant);

var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RoxFlag = function (_Variant) {
  _inherits$2(RoxFlag, _Variant);

  function RoxFlag() {
    var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck$6(this, RoxFlag);

    var _this = _possibleConstructorReturn$2(this, (RoxFlag.__proto__ || Object.getPrototypeOf(RoxFlag)).call(this, defaultValue ? 'true' : 'false', ['false', 'true']));

    _this._entityType = 'flag';
    return _this;
  }

  _createClass$6(RoxFlag, [{
    key: 'isEnabled',
    value: function isEnabled(context) {
      return this._normalizeValue(this.getValue(context));
    }
  }, {
    key: '_getInternalIsEnabled',
    value: function _getInternalIsEnabled(callContext, context) {
      return this._normalizeValue(this.getInternalValue(callContext, context));
    }
  }, {
    key: '_normalizeValue',
    value: function _normalizeValue(value) {
      if (typeof value === 'boolean') return value;
      return value === 'true';
    }
  }]);

  return RoxFlag;
}(Variant);

var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NodeEntitiesProvider = function () {
  function NodeEntitiesProvider() {
    _classCallCheck$4(this, NodeEntitiesProvider);
  }

  _createClass$4(NodeEntitiesProvider, [{
    key: 'createFlag',
    value: function createFlag(defaultValue) {
      return new RoxFlag(defaultValue);
    }
  }, {
    key: 'createVariant',
    value: function createVariant(defaultValue, options) {
      return new Variant(defaultValue, options);
    }
  }]);

  return NodeEntitiesProvider;
}();

var EntitiesProvider = new NodeEntitiesProvider();

var createRoxClient = roxBase$1.createRoxClient;


var client = createRoxClient({
  DeviceProperties: DeviceProperties$1,
  getDefaultCustomProperties: getDefaultCustomProperties,
  DefaultSetupOptions: defaultSetupOptions,
  RoxCache: RoxCache$1,
  RoxCrypto: RoxCrypto,
  EntitiesProvider: EntitiesProvider
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RoxLogger = roxBase$1.RoxLogger;
var configuration = roxBase$1.Config;
var Repositories = roxBase$1.Repositories;

var Rox$1 = function () {
  function Rox() {
    _classCallCheck(this, Rox);
  }

  _createClass(Rox, [{
    key: 'setup',

    /**
     * Initiate connection with ROX servers for the application identified by the application key. The registered containers will be synced and Rox entities will get the appropriate values.
     * @param {String} appKey application key as appears in ROX dashboard
     * @param {Object} options optional configuration object
     */
    value: function setup(appKey) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      RoxLogger.setVerboseMode(options.debugLevel);
      if (options.configuration) {
        configuration.setActive(options.configuration);
      }

      client.setKey(appKey);

      return client.setup(options).then(function () {
        if (client.disableNetwork) {
          return client.fetchCacheOnly();
        }
        client.sendState();
        return client.fetchPeriodically();
      });
    }
  }, {
    key: 'setCustomStringProperty',
    value: function setCustomStringProperty(key, value) {
      client.setCustomProperty(key, String, value);
    }
  }, {
    key: 'setCustomNumberProperty',
    value: function setCustomNumberProperty(key, value) {
      client.setCustomProperty(key, Number, value);
    }
  }, {
    key: 'setCustomBooleanProperty',
    value: function setCustomBooleanProperty(key, value) {
      client.setCustomProperty(key, Boolean, value);
    }

    /**
     * Register a container of Rox entities by specifiying a namespace.
     * @param {String} name Container name
     * @param {Object} container Object literal whose properties are Rox entities
     */

  }, {
    key: 'register',
    value: function register(name, container) {
      client.register(name, container);
    }
  }, {
    key: 'fetch',
    value: function fetch() {
      client && client.fetch();
    }
  }, {
    key: 'setDynamicCustomPropertyRule',
    value: function setDynamicCustomPropertyRule(handler) {
      client.setDynamicCustomPropertyRule(handler);
    }
  }, {
    key: 'flags',
    get: function get() {
      return Repositories.Flags.flags;
    }
  }, {
    key: 'dynamicApi',
    get: function get() {
      return client.dynamicApi;
    }
  }]);

  return Rox;
}();

var instance = new Rox$1();

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseRemoteConfiguration = roxBase$1.Entities.Configuration;

var NodeRemoteConfiguration = function (_BaseRemoteConfigurat) {
  _inherits$3(NodeRemoteConfiguration, _BaseRemoteConfigurat);

  function NodeRemoteConfiguration() {
    _classCallCheck$7(this, NodeRemoteConfiguration);

    return _possibleConstructorReturn$3(this, (NodeRemoteConfiguration.__proto__ || Object.getPrototypeOf(NodeRemoteConfiguration)).apply(this, arguments));
  }

  return NodeRemoteConfiguration;
}(BaseRemoteConfiguration);

var GET = 'GET';
var POST = 'POST';
var PUT = 'PUT';
var DELETE = 'DELETE';

var FLAGS = '/api/flags';
var INDEX = '/';

var TYPES = {
  HTML: 'text/html; charset=utf-8',
  JSON: 'application/json'
};

var METHODS = {
  GET: GET,
  POST: POST,
  PUT: PUT,
  DELETE: DELETE
};

var ROUTES = {
  INDEX: INDEX,
  FLAGS: FLAGS
};

var flagsPattern = new RegExp('^' + ROUTES.FLAGS + '/?(.+)?');

var allFlagsJSON = function allFlagsJSON() {
  return {
    body: roxBase$1.Repositories.Flags.flags.map(function (f) {
      return f.dump();
    }),
    type: TYPES.JSON
  };
};

// will change in future
var API_VERSION = 'v0';
var ROXBOARD_SERVER = '//connect.rollout.io/' + API_VERSION;

var serveIndex = function serveIndex() {
  return '<!DOCTYPE html> <html lang="en"><head><meta charset="utf-8" /><title>ROXBoard</title><link rel="stylesheet" href="' + ROXBOARD_SERVER + '/styles.css" /><script>\nvar initialData = ' + JSON.stringify(allFlagsJSON().body) + ';\n</script>\n</head><body><div id="root"></div></body><script src="' + ROXBOARD_SERVER + '/bundle.js"></script></html>';
};

var extractBodyFromRequest = function extractBodyFromRequest(req) {
  return new Promise(function (resolve, reject) {
    try {
      var body = '';
      req.on('readable', function () {
        var data = req.read();
        body = data ? body + data : body;
      });
      req.on('end', function () {
        return resolve(body);
      });
      req.on('close', function () {
        return resolve('');
      });
    } catch (e) {
      reject(e);
    }
  });
};

var handleGET = function handleGET(url$$1) {
  switch (url$$1) {
    case ROUTES.FLAGS:
      return allFlagsJSON();
    default:
      return {
        body: serveIndex(),
        type: TYPES.HTML
      };
  }
};

var handlePOST = function handlePOST(req) {
  switch (req.url) {
    case ROUTES.FLAGS:
      return extractBodyFromRequest(req).then(function (body) {
        if (typeof body === 'string') body = JSON.parse(body);
        if (!(body instanceof Array)) body = [body];

        body.forEach(function (_ref) {
          var name = _ref.name,
              value = _ref.value;

          if (!name || !value) return;
          setOverride(name, value);
        });
        return allFlagsJSON();
      });
    default:
      return Promise.resolve({ code: 404, body: '' });
  }
};

var handleDELETE = function handleDELETE(req) {
  var matched = req.url.match(flagsPattern);
  if (matched) {
    // delete something
    if (matched[1]) {
      // delete specific override
      clearOverride(matched[1]);
    } else {
      // delete all overrides
      clearAllOverrides();
    }
  } else {
    return { code: 404, body: '' };
  }
  return { body: '' };
};

var PORT = 3000;

var requestHandler = function requestHandler(req, res) {
  var response = Promise.resolve({
    body: ''
  });
  var method = req.method,
      url$$1 = req.url;

  switch (method) {
    case METHODS.GET:
      response = Promise.resolve(handleGET(url$$1));
      break;
    case METHODS.POST:
      response = Promise.resolve(handlePOST(req));
      break;
    case METHODS.DELETE:
      response = Promise.resolve(handleDELETE(req));
      break;
  }

  response.then(function (_ref) {
    var body = _ref.body,
        type = _ref.type,
        code = _ref.code;

    var _body = typeof body === 'string' ? body : JSON.stringify(body);

    res.writeHead(code || 200, {
      'Content-Length': Buffer.byteLength(_body || ''),
      'Content-Type': type || 'text/plain'
    });

    res.write(_body);
  }).catch(function (error) {
    res.statusCode = 500;
    console.error(error); // eslint-disable-line no-console
  }).then(function () {
    return res.end();
  });
};
var server = http.createServer(requestHandler);

function startAdminServer() {
  var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PORT;

  return new Promise(function (resolve, reject) {
    server.listen(port, function (error) {
      if (error) {
        console.error(error); // eslint-disable-line no-console
        return reject(error);
      }
      return resolve(server);
    });
  });
}

instance.startAdminServer = startAdminServer;
instance.Configuration = NodeRemoteConfiguration;
instance.setContext = roxBase$1.Context.Manager.setContext;
instance.Variant = Variant;
instance.Flag = RoxFlag;
instance.overrides = Overrider;

module.exports = instance;
